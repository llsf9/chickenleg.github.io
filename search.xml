<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Collection of CGO</title>
    <url>/2022/05/28/Collection-of-CGO/</url>
    <content><![CDATA[<h1 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h1><ul>
<li><a href="https://github.com/ericjang/awesome-graphics#games">https://github.com/ericjang/awesome-graphics#games</a></li>
<li><a href="https://kesen.realtimerendering.com">https://kesen.realtimerendering.com</a></li>
</ul>
<h1 id="Image-based-Editing-and-Reconstruction"><a href="#Image-based-Editing-and-Reconstruction" class="headerlink" title="Image-based Editing and Reconstruction"></a>Image-based Editing and Reconstruction</h1><ul>
<li>Image stitch / photomontage<ul>
<li><a href="http://grail.cs.washington.edu/projects/photomontage/">http://grail.cs.washington.edu/projects/photomontage/</a> Interactive Digital Photomontage</li>
<li><a href="http://cs.brown.edu/courses/cs129/results/proj2/taox/">http://cs.brown.edu/courses/cs129/results/proj2/taox/</a> Gradient Domain Fusion Using Poisson Blending</li>
</ul>
</li>
</ul>
<h1 id="Course"><a href="#Course" class="headerlink" title="Course"></a>Course</h1><p>Not only the slides of courses but also lots of useful learning materials.</p>
<ul>
<li><a href="http://graphics.cs.cmu.edu/courses/15-463/2012_fall/463.html">http://graphics.cs.cmu.edu/courses/15-463/2012_fall/463.html</a> Computational Photography</li>
<li><a href="http://cs.brown.edu/courses/cs129/">http://cs.brown.edu/courses/cs129/</a> Computational Photography and Image Manipulation</li>
</ul>
<h1 id="book"><a href="#book" class="headerlink" title="book"></a>book</h1><ul>
<li><a href="http://szeliski.org/Book/">http://szeliski.org/Book/</a> Computer Vision: Algorithms and Applications(also contain lots of useful courses links)</li>
</ul>
<h1 id="Interpolation"><a href="#Interpolation" class="headerlink" title="Interpolation"></a>Interpolation</h1><ul>
<li>what is interpolation<br><a href="https://www.geeksforgeeks.org/interpolation-methods-in-computer-graphics/">https://www.geeksforgeeks.org/interpolation-methods-in-computer-graphics/</a></li>
<li>application in shading<br><a href="https://user.numazu-ct.ac.jp/~fujio/personal/jp/kougi/zukei/slide/Shading.pdf">https://user.numazu-ct.ac.jp/~fujio/personal/jp/kougi/zukei/slide/Shading.pdf</a></li>
</ul>
<h1 id="Dense-correspondence"><a href="#Dense-correspondence" class="headerlink" title="Dense correspondence"></a>Dense correspondence</h1><ul>
<li><a href="http://blog.yoqi.me/wp/2118.html">http://blog.yoqi.me/wp/2118.html</a> 无监督的Dense Correspondence学习方法</li>
</ul>
<h1 id="Shape-Generation"><a href="#Shape-Generation" class="headerlink" title="Shape Generation"></a>Shape Generation</h1><ul>
<li>GAN</li>
<li>Flow</li>
<li><p>Diffusion</p>
</li>
<li><p><a href="https://dl.acm.org/doi/pdf/10.1145/3450626.3459766">https://dl.acm.org/doi/pdf/10.1145/3450626.3459766</a> SP-GAN: Sphere-Guided 3D Shape Generation and Manipulation</p>
<ul>
<li>3D shape generation: </li>
</ul>
</li>
</ul>
<h1 id="Seam-carving"><a href="#Seam-carving" class="headerlink" title="Seam carving"></a>Seam carving</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/109428038">https://zhuanlan.zhihu.com/p/109428038</a> Seam Carving算法</li>
</ul>
<h1 id="genetic-algorithms"><a href="#genetic-algorithms" class="headerlink" title="genetic algorithms"></a>genetic algorithms</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/100337680">https://zhuanlan.zhihu.com/p/100337680</a></li>
<li><a href="https://esslab.jp/~ess/teaching/2022/cgo/11/">https://esslab.jp/~ess/teaching/2022/cgo/11/</a></li>
<li><a href="https://blog.csdn.net/u011001084/article/details/49308289">https://blog.csdn.net/u011001084/article/details/49308289</a></li>
<li><a href="https://blog.csdn.net/qq_16236875/article/details/100888969">https://blog.csdn.net/qq_16236875/article/details/100888969</a></li>
</ul>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><ul>
<li><a href="https://blog.csdn.net/Little_White_9/article/details/124435560">https://blog.csdn.net/Little_White_9/article/details/124435560</a> diffusion model</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>CGO</tag>
      </tags>
  </entry>
  <entry>
    <title>HexoTags</title>
    <url>/2022/05/05/HexoTags/</url>
    <content><![CDATA[<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note [class]%&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>空白</li>
<li>default</li>
<li>primary</li>
<li>success</li>
<li>info</li>
<li>warning</li>
<li>danger</li>
</ul>
<h2 id="Mermaid"><a href="#Mermaid" class="headerlink" title="Mermaid"></a>Mermaid</h2><div class="note modern"><p>使用mermaid标籤可以绘製Flowchart（流程图）、Sequence diagram（时序图 ）、Class Diagram（类别图）、State Diagram（状态图）、Gantt（甘特图）和Pie Chart（圆形图），具体可以查看<a href="https://mermaid-js.github.io/mermaid/#/">Mermaide文档</a></p>
</div>
<h2 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a>Tabs</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br></pre></td></tr></table></figure>
<div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">表格1</button></li><li class="tab"><button type="button" data-href="#test1-2">表格2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>这是1</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>这是2</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h2 id="label"><a href="#label" class="headerlink" title="label"></a>label</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% label 我是 %&#125;&#123;% label 什么 blue %&#125;&#123;%label 颜色 red %&#125;</span><br></pre></td></tr></table></figure>
<mark class="hl-label default">我是</mark> <mark class="hl-label blue">什么</mark> <mark class="hl-label red">颜色</mark> 
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Colorization using Optimization</title>
    <url>/2022/05/06/Colorization-using-Optimization/</url>
    <content><![CDATA[<p><img src="https://p.ipic.vip/mwdw7t.png" alt=""></p>
<h2 id="论文概述-1"><a href="#论文概述-1" class="headerlink" title="论文概述 [1]"></a>论文概述 [1]</h2><blockquote>
<p>在本文中，我们提出了一种简单的着色方法:基于一个简单前提：时空中具有相似强度(intensity:Y)的<strong>相邻像素应该具有相似的颜色</strong>。 我们使用次成本函数形式化这个前提，并获得一个可以使用标准技术有效解决的优化问题。</p>
</blockquote>
<p>[1]Levin, Anat, Dani Lischinski, and Yair Weiss. “Colorization using optimization.” ACM SIGGRAPH 2004 Papers. 2004. 689-694.</p>
<h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><p>Y可以通过gray图像作为已知信息，因此我们需要通过临近像素的推测U和V<br>MINIMIZE</p>
<script type="math/tex; mode=display">J(U) = \sum_r \left( U(r) - \sum_{s \in N(r)} w_{rs} U(s) \right)^2</script><script type="math/tex; mode=display">J(V) = \sum_r \left( V(r) - \sum_{s \in N(r)} w_{rs} V(s) \right)^2</script><ul>
<li>r: 目标像素 N(r):临近像素</li>
<li>$w_{rs}$的条件<ul>
<li>两像素间Y越相似，w越大；两像素间Y差值越大，w越小</li>
<li>和为1</li>
</ul>
</li>
</ul>
<h3 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h3><p>相邻像素具有相似Y时应该具有相似的U和V</p>
<h3 id="权重函数"><a href="#权重函数" class="headerlink" title="权重函数"></a>权重函数</h3><script type="math/tex; mode=display">w_{rs} \propto \exp \left( \frac{-\left(Y(r)-Y(s)\right)^2}{2 \sigma_r^2} \right)</script><ul>
<li>$\sigma_r^2$为包含r的临近像素的variance</li>
</ul>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol>
<li>二乘问题的目的函数转换为解线性方程组Ax=b的问题<ul>
<li>如果按照稠密矩阵构造A就需要使用$(A^TA)^{-1}A^Tb$计算，将会十分庞大；如果用稀疏矩阵则会大大减少计算量<blockquote>
<p>呃呃搞明白以后思路就是如此简单。。。。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="import库"><a href="#import库" class="headerlink" title="import库"></a>import库</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 依赖库 </span></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> color</span><br><span class="line"><span class="keyword">from</span> scipy.sparse <span class="keyword">import</span> csr_matrix</span><br><span class="line"><span class="keyword">from</span> scipy.sparse.linalg <span class="keyword">import</span> spsolve</span><br></pre></td></tr></table></figure>
<h3 id="图像预处理"><a href="#图像预处理" class="headerlink" title="图像预处理"></a>图像预处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load the images</span></span><br><span class="line"><span class="comment"># 打开图片转换为RGB再转换为YUV</span></span><br><span class="line">img_in   = color.rgb2yuv( np.array( Image.<span class="built_in">open</span>( <span class="string">&#x27;baby.png&#x27;</span> ).convert(<span class="string">&quot;RGB&quot;</span>), dtype=<span class="built_in">float</span> ) / <span class="number">255</span> )</span><br><span class="line">img_edit = color.rgb2yuv( np.array( Image.<span class="built_in">open</span>( <span class="string">&#x27;baby_marked.png&#x27;</span> ).convert(<span class="string">&quot;RGB&quot;</span>), dtype=<span class="built_in">float</span> ) / <span class="number">255</span> )</span><br><span class="line">img_hint = np.zeros( img_edit.shape )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过图片像素相减提取hint</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">idx = (np.<span class="built_in">abs</span>((img_in-img_edit).<span class="built_in">sum</span>(<span class="number">2</span>)) &gt; <span class="number">1e-4</span>)</span><br><span class="line">img_hint[ idx ] = img_edit[ idx ]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Image.open()</code>：返回一个image的对象(shape=(w,h))<ul>
<li><code>Image.open().convert(&quot;RGB&quot;)</code>：返回一个image的RGB对象(shape=(w,h,c))</li>
</ul>
</li>
<li><code>sum(n)</code>：沿n维的sum</li>
</ul>
<h3 id="生成稀疏矩阵A"><a href="#生成稀疏矩阵A" class="headerlink" title="生成稀疏矩阵A"></a>生成稀疏矩阵A</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create the optimization problem</span></span><br><span class="line">w = img_edit.shape[<span class="number">0</span>]</span><br><span class="line">h = img_edit.shape[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># window size</span></span><br><span class="line">wpx = <span class="number">1</span> </span><br><span class="line"><span class="comment"># u和v：只放入已确定颜色的像素id的uv值</span></span><br><span class="line">b_u = np.zeros( (w*h,) )</span><br><span class="line">b_v = b_u.copy()</span><br><span class="line"><span class="comment"># Sparse matrix，一对(row,col)代表一对邻居关系的像素，dat内存储权重</span></span><br><span class="line">row = []</span><br><span class="line">col = []</span><br><span class="line">dat = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历 w * h = n</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(h):</span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> <span class="built_in">range</span>(w):</span><br><span class="line">        <span class="comment"># （w，v）to index</span></span><br><span class="line">        i = v*w + u</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add first entry U(r) for both  channels</span></span><br><span class="line">        <span class="comment"># 像素本身等于自身，因此稀疏矩阵A的对角均为1</span></span><br><span class="line">        row.append( i )</span><br><span class="line">        col.append( i )</span><br><span class="line">        dat.append( <span class="number">1.</span> )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Skip coloured areas,</span></span><br><span class="line">        <span class="comment"># 已经在给的hint里上色的区域就跳过</span></span><br><span class="line">        <span class="keyword">if</span> idx[u,v]:</span><br><span class="line">            b_u[i] = img_edit[u,v,<span class="number">1</span>]</span><br><span class="line">            b_v[i] = img_edit[u,v,<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 求r的neighbour范围</span></span><br><span class="line">        umin = <span class="built_in">max</span>(<span class="number">0</span>,u-wpx)</span><br><span class="line">        umax = <span class="built_in">min</span>(w,u+wpx+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        vmin = <span class="built_in">max</span>(<span class="number">0</span>,v-wpx)</span><br><span class="line">        vmax = <span class="built_in">min</span>(h,v+wpx+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 求neighbour范围内的variance</span></span><br><span class="line">        patch = img_in[ umin:umax, vmin:vmax, <span class="number">0</span> ]</span><br><span class="line">        mu_r = np.mean( patch )</span><br><span class="line">        sigma_r = np.var( patch )</span><br><span class="line">        sigma_r = <span class="built_in">max</span>( sigma_r, <span class="number">1e-6</span> )</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 求r的Y</span></span><br><span class="line">        Yr = img_in[u,v,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Go over neighbours</span></span><br><span class="line">        <span class="comment"># 遍历neighbour，求各自的w</span></span><br><span class="line">        N = []</span><br><span class="line">        wrs = []</span><br><span class="line">        <span class="keyword">for</span> nu <span class="keyword">in</span> <span class="built_in">range</span>( umin, umax ):</span><br><span class="line">            <span class="keyword">for</span> nv <span class="keyword">in</span> <span class="built_in">range</span>( vmin, vmax ):</span><br><span class="line">                j = nv*w + nu</span><br><span class="line">                <span class="keyword">if</span> i==j:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                Ys = img_in[nu,nv,<span class="number">0</span>]</span><br><span class="line">                wrs.append(np.exp(-<span class="number">1</span>*(Yr-Ys)*(Yr-Ys)/ <span class="number">2</span> / sigma_r))</span><br><span class="line">                N.append(j)</span><br><span class="line">        wrs = np.array( wrs )</span><br><span class="line">        <span class="comment"># 对w的约束条件：和必须为1</span></span><br><span class="line">        wrs /= wrs.<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据求出的w完善矩阵</span></span><br><span class="line">        <span class="keyword">for</span> k,j <span class="keyword">in</span> <span class="built_in">enumerate</span>(N):</span><br><span class="line">            row.append(i)</span><br><span class="line">            col.append(j)</span><br><span class="line">            dat.append(-wrs[k])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最终生成一个大小为(wh,wh)的，包含所有点与点之间的权重的矩阵</span></span><br><span class="line">A = csr_matrix( (dat, (row,col)) )</span><br></pre></td></tr></table></figure>
<ul>
<li><code>csr_matrix( (data, (row_index,col_index)) )</code>:  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">csr_matrix( ([<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>], ([<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>])) ).toarray()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">   [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">   [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">   [<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>]], dtype=int64)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="解方程组生成目标图像"><a href="#解方程组生成目标图像" class="headerlink" title="解方程组生成目标图像"></a>解方程组生成目标图像</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Solve the optimization and display results</span></span><br><span class="line">Y = img_in[:,:,<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">U = spsolve(A, b_u).reshape( h, w, <span class="number">1</span> ).transpose( (<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>) )</span><br><span class="line">V = spsolve(A, b_v).reshape( h, w, <span class="number">1</span> ).transpose( (<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>) )</span><br><span class="line"></span><br><span class="line">img_out = np.concatenate( (Y,U,V), axis=<span class="number">2</span> )</span><br><span class="line">plt.imshow( color.yuv2rgb(img_out) )</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear models for classification</title>
    <url>/2022/05/23/Linear%20models%20for%20classification/</url>
    <content><![CDATA[<h2 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h2><ul>
<li>goal: The goal in <strong>classification</strong> is to take an input vector x and to <strong>assign</strong> it to one of $K$ discrete classes $C_k$ where k = 1, . . . , K</li>
</ul>
<blockquote>
<p>Regression : take continuous values</p>
</blockquote>
<div class="note info modern"><p>NOTE<br>representation</p>
<ul>
<li>Two class: target variable $t \in \{0, 1\}$ such that t = 1 represents class C1 and t = 0 represents class C2</li>
<li>Multi class: t is a vector like (1,0,0,0,0,0…) when its class is C0</li>
</ul>
</div>
<p>For linear regression, we only need $y=w^Tx+w_0$to obtain a <strong>real number</strong>;</p>
<p>For classification problem, we wish to predict <strong>discrete class labels</strong>, or more generally <strong>posterior probabilities</strong> that lie in the range (0, 1)</p>
<p>So we use a nonlinear function which called  activation function:</p>
<script type="math/tex; mode=display">y(x)=f(w^Tx+w_0)</script><h2 id="2-Models"><a href="#2-Models" class="headerlink" title="2. Models"></a>2. Models</h2><ul>
<li>Discriminant Function 判别函数<ul>
<li>Inputs 𝑥 directly into decisions</li>
<li>$R^n -&gt; R$</li>
<li>SVM</li>
</ul>
</li>
</ul>
<h2 id="3-Discriminant-Function"><a href="#3-Discriminant-Function" class="headerlink" title="3. Discriminant Function"></a>3. Discriminant Function</h2><h3 id="3-1-Two-class"><a href="#3-1-Two-class" class="headerlink" title="3.1 Two class"></a>3.1 Two class</h3><script type="math/tex; mode=display">y(x)=w^Tx+w_0</script><ul>
<li>$y(x)\geq 0$ -&gt; C1</li>
<li>Otherwise, C2</li>
<li>decision boundary : $y(x) = 0$<ul>
<li><strong>perpendicular</strong> to 𝐰.</li>
<li><strong>Displacement</strong> from origin =<br>$\frac{-w_0}{||w||}$</li>
<li><strong>perpendicular distance</strong> r of point x from decision surface<script type="math/tex; mode=display">r=\frac{y(x)}{||x||}</script><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2icwi9erhj20hi0b23z9.jpg" alt=""><br>It’s relate to difficulty of classification</li>
</ul>
</li>
</ul>
<h3 id="3-2-multi-classes"><a href="#3-2-multi-classes" class="headerlink" title="3.2 multi classes"></a>3.2 multi classes</h3>]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>PRML</tag>
      </tags>
  </entry>
  <entry>
    <title>SIFT</title>
    <url>/2022/05/13/SIFT/</url>
    <content><![CDATA[<h2 id="SIFT究竟在做什么？"><a href="#SIFT究竟在做什么？" class="headerlink" title="SIFT究竟在做什么？"></a>SIFT究竟在做什么？</h2><h3 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a>WHAT</h3><p>SIFT属于传统特征提取方式，与通过深度学习的反复学习提取出的特征值不同，传统特征提取方式需要通过人工计算和模拟实验找到所需要的特征点。一个好的特征量应该具有尺度不变的性质，本文就是在解释通过怎样的计算步骤能找到这样的特征量。</p>
<h3 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h3><p>特征量往往被用在物体识别，并且应该是分辨度高的，以区分于杂乱的背景和庞大的数据库。</p>
<h3 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h3><p>我们主要使用四个步骤：1.尺度空间的极值检测，2.关键点的定位，3. 方向分配 4. 关键点描述，来提取我们所需要的特征量。</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>这篇文章帮助我们从图片中提取出图像特征，能满足即使当这个图片中某一事物或场景发生了失真，视角偏移，噪点增添或是光线改变时，也能将图片间的相关点进行对应。而且他它们是易于区分的特征，即使是从庞大的特征库中也能利用它们找到对应的真正的物体或场景。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>分为以下三步</p>
<ol>
<li>尺度空间的极值提取</li>
<li>关键点定位</li>
<li>方向分配</li>
<li>关键点描述</li>
</ol>
<p>这一系列的方法称作为SIFT,即尺度不变的特征转换。</p>
<h3 id="1-尺度空间的极值提取"><a href="#1-尺度空间的极值提取" class="headerlink" title="1. 尺度空间的极值提取"></a>1. 尺度空间的极值提取</h3><h4 id="生成高斯图像、尺度空间"><a href="#生成高斯图像、尺度空间" class="headerlink" title="生成高斯图像、尺度空间"></a>生成高斯图像、尺度空间</h4><p>极值提取的计算式，将使用DoG进行计算。首先我们已经知道唯一可行的尺度空间核就是高斯核，因此我们使用高斯函数对图像进行卷积从而得到尺度空间。其次，Lindebeg在1994年提出了LoG是对于尺度不变检测的必要算子。并且，Mikolajczyk提出利用LoG的最小值和最大值之差可以求出图片的稳定特征。而DoG正好可以近似于LoG。</p>
<p>对于每个尺度空间，通过将原始图像与高斯核不断卷积，并将临近的生成图像相减形成高斯差值图像。之后，对图像进行下采样，再进行同样的工作。这样保证采样精度不变的情况下，计算量大大下降。</p>
<h4 id="局部极值提取"><a href="#局部极值提取" class="headerlink" title="局部极值提取"></a>局部极值提取</h4><p>每个点将会和坐标空间上的8个临近点，以及尺度空间上的18个点，共计26个点进行比较。只有在27个点中是最小或最大才会被定义为极值。由于我们可以进行一些前处理筛选掉大部分的点，所以极值验证的过程并不会花费很大。</p>
<p>明显的是，采样频率关系到极值的选择。但不幸的是并没有确定的采样频率能使我们一定能找到所需的极值。因此我们使用实验的方法来决定最优频率。</p>
<h5 id="尺度上的采样频率"><a href="#尺度上的采样频率" class="headerlink" title="尺度上的采样频率"></a>尺度上的采样频率</h5><p>我们测试了当改变尺度空间上的采样时，重现率和关键点检测数量的改变趋势。结果表明，当采样频率增加时，重现率有下降趋势，这有可能因为即使找到了更多的极值，但他们不够稳定；并且，随着频率增加，更多的关键点被检测出来，虽然他们有助于物体检测，但运算量也大大上升，因此我们折中选择了3这个尺度空间的采样频率。</p>
<h5 id="空间上的采样频率"><a href="#空间上的采样频率" class="headerlink" title="空间上的采样频率"></a>空间上的采样频率</h5><p>通过测试预平滑的采样频率与重现率的关系我们发现，当频率越大重现率也越大，但为了保证运行的效率，我们选择了1.6这个值。</p>
<h3 id="2-精确的关键点定位"><a href="#2-精确的关键点定位" class="headerlink" title="2. 精确的关键点定位"></a>2. 精确的关键点定位</h3><p>上个步骤中我们找到了离散空间的极值候选者，但不一定是真正的连续函数上的极值。本章通过对取样点的D(x)求导得出偏移量，以寻找真正的极值。首先，如果偏移值大于0.5则认为极值在相邻的采样点。其次，如果有极值点的D(x)是小于0.03的我们认为它是不稳定的，因此也会被舍弃。</p>
<h4 id="消除边缘响应"><a href="#消除边缘响应" class="headerlink" title="消除边缘响应"></a>消除边缘响应</h4><p>当主曲率过大时我们认为这是边缘上的点，由于边缘点并不稳定我们需要去除。通过计算，我们只要通过计算海塞矩阵的对角和行列式的比值就能求出特征值之比，这大大减少了计算量。本文将特征值的比值阈值设为10，大于10的将被去除。</p>
<h3 id="3-方向分配"><a href="#3-方向分配" class="headerlink" title="3. 方向分配"></a>3. 方向分配</h3><p>对于每个关键点，我们通过统计临近区域的点的向量和角度来确定关键点的方向。通过直方图的形式统计被分配在各个角度的临近点的数量，取最多的为关键点的方向。此外，若有其他方向的统计值高于最高值的80%，我们将其认定为第二方向。</p>
<h3 id="4-特征点描述"><a href="#4-特征点描述" class="headerlink" title="4. 特征点描述"></a>4. 特征点描述</h3><p>我们已经知道使用神经元模型，即计算出特定方向和空间次数的梯度可以得到非常稳定的特征量，可以用于视角改变和亮度改变的问题。</p>
<h4 id="特征量表现"><a href="#特征量表现" class="headerlink" title="特征量表现"></a>特征量表现</h4><p>通过计算和统计关键点周围像素的向量方向分布，对关键点进行描述。本文中我们将对16<em>16的范围的区域分成4\</em>4的格子，来对它们的8个向量方向进行统计。<br>此外，为了对光照变化具有不变性，我们还要对向量归一化。这样能减少光亮变化而产生的对梯度带来的线性变化。其次，为向量长度设置阈值，减小值较大的向量的重要度，以减少对非线性光照变化的敏感度。</p>
<h4 id="对仿射变换的敏感性"><a href="#对仿射变换的敏感性" class="headerlink" title="对仿射变换的敏感性"></a>对仿射变换的敏感性</h4><p>根据实验，当仿射度上升时匹配度大幅度下降。但实际上在3D图像上的可旋转范围较小，仿射不变性并不是那么重要。而如果在平面图片上时，我们可以使用xx的方法生成额外的SIFT特征量，使得最终生成标准特征库三倍量的特征。</p>
<h4 id="对大数据集的对比"><a href="#对大数据集的对比" class="headerlink" title="对大数据集的对比"></a>对大数据集的对比</h4><p>更多是因为初始特征的位置和方向的分配问题而不是特征的可区分度造成的</p>
<h2 id="对物体识别的应用"><a href="#对物体识别的应用" class="headerlink" title="对物体识别的应用"></a>对物体识别的应用</h2><h3 id="1-关键点匹配"><a href="#1-关键点匹配" class="headerlink" title="1. 关键点匹配"></a>1. 关键点匹配</h3><p>我们对每个关键点与数据库中的特征进行匹配，得到欧几里得距离最近的候选项。但是实际上许多特征来自于杂乱的背景或对于这个物体的识别并没有帮助。因此我们通过一个高效的手法剔除掉这些无用的特征。这个方法就是对比与最近的正确图像的距离，和最近的错误图像的距离之比。当这个比值大于0.8时（即错误图像的距离高于正确图像的距离的80%时），我们就淘汰这个特征。</p>
<h3 id="有效的最近邻法"><a href="#有效的最近邻法" class="headerlink" title="有效的最近邻法"></a>有效的最近邻法</h3><p>我们使用BBF算法来搜索最近的点。这个算法对于我们的特征值最有效，考虑原因可能是上章提到我们只需要探索距离比值小于0.8的特征点。</p>
<h3 id="霍夫变换聚类"><a href="#霍夫变换聚类" class="headerlink" title="霍夫变换聚类"></a>霍夫变换聚类</h3><p>为了提高对小物体和被遮挡物体的识别问题，我们希望即使少类的特征也能识别出物体。而通过霍夫变换将特征值聚类的方法能提升这一可能性。</p>
<p>[1] <a href="https://blog.csdn.net/lavender19/article/details/120396145">https://blog.csdn.net/lavender19/article/details/120396145</a><br>[2]<a href="https://blog.csdn.net/shiyongraow/article/details/78296710">https://blog.csdn.net/shiyongraow/article/details/78296710</a><br>[3]<a href="https://www.cnblogs.com/shine-lee/p/10950963.html">https://www.cnblogs.com/shine-lee/p/10950963.html</a> 仿射变换</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>【项目实战】考虑内容的图片缩放</title>
    <url>/2022/07/20/content-aware-image-resizing/</url>
    <content><![CDATA[<h1 id="项目报告"><a href="#项目报告" class="headerlink" title="项目报告"></a>项目报告</h1><p><a href="/butterfly/cgo.pdf">pdflink<a><br><img src="https://p.ipic.vip/1skxgt.png" alt=""></p>
<h1 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h1><p>对于图片缩放，我们希望在缩放时却不影响主体的变换。一般来说，缩放技术有基于离散和连续的两种方法，离散型通常是迭代地寻找一排（或者一列）最小能量的像素，以删除在原图片中无效的像素点；连续型则通过形变等手法改变整个图片的比例。本项目基于Seam Carving [1]和 Image Warping [2]的论文进行代码的复现和结果的比较。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><ul>
<li>进化算法的一种，优化方式属于随机优化</li>
<li>受生物遗传算法的启发</li>
<li>常用于1. 非连续，非凸，非可微，非线性等难以定义的目标函数 2. 或当搜索空间过大难以使用普通优化方式的问题</li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol>
<li>随机生成一批个体(individual)，这一批个体形成了一个群落(population)<ul>
<li>每个个体其实就是一个解(solution)</li>
</ul>
</li>
<li>每个个体具有一个适应度(fitness)的评判值，代表着它对于目标问题的分数</li>
<li>根据适应度的高低，高适应度的个体会相互繁衍(crossover)产生后代（下一个个体），并且会进行复制(reproduce)（在迭代中被留下）；低适应度的则在下一次进化中被淘汰(discard)</li>
<li>在产生个体时，还会有一定的几率发生突变(mutation)；突变的发生与适应度无关</li>
<li>重复以上的进化过程直到结束</li>
</ol>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在图片缩放问题中，遗传算法中的每个个体就是要找的最小影响的路线，以垂直路线为例： ${s^v}$。为了不改变原图片的结构，我们限制路线的最大跨度不能超过1（即只能在九宫格内移动），可以如下式表示：</p>
<p><img src="https://p.ipic.vip/lkpqmd.jpg" alt=""></p>
<p>最终我们要寻找的最优路线 ${s^{v*}}$，我们希望它能够达到是图片中影响力最小（能量值最小）的一条路线。即：</p>
<p><img src="https://p.ipic.vip/lkpqmd.jpg" alt=""></p>
<p><strong>注</strong></p>
<p>：除了遗传算法这种随机算法，我们还要使用动态算法(Dynamic Programming)来解决该问题。由于我们想找到最小能量的路线，因此在探索路线时遵循以下的转换方程式：<br><img src="https://p.ipic.vip/cr0jaq.jpg" alt=""></p>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><ul>
<li>初始个体：random walk。随机定义一个pivot数作为开始的行i，在这一行随机选取一个点，其他行以[-1,1]为区域进行random walk。</li>
<li>复制：当前种群内的前20%的最优个体</li>
<li>繁衍：选一个随机数，令两个个体的随机数后的位置对调</li>
<li>突变：根据高斯分布对个体的一部分元素进行突变</li>
</ul>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="能量函数（能量图）"><a href="#能量函数（能量图）" class="headerlink" title="能量函数（能量图）"></a>能量函数（能量图）</h2><p>尝试了边缘检测和物体的显著性检测两种能量函数并对其进行了比较。</p>
<h3 id="Static-Saliency-Spectral-Residual"><a href="#Static-Saliency-Spectral-Residual" class="headerlink" title="Static Saliency Spectral Residual"></a><strong><strong>Static Saliency Spectral Residual</strong></strong></h3><p>模拟注意前视觉搜索的行为。该算法对每幅图像的对数谱进行分析，得到谱残差SR (Spectral Residual)</p>
<h3 id="Static-Saliency-Fine-Grained"><a href="#Static-Saliency-Fine-Grained" class="headerlink" title="Static Saliency Fine Grained"></a><strong>Static Saliency Fine Grained</strong></h3><p>该方法基于空间尺度差异计算显著性</p>
<p><img src="https://p.ipic.vip/xf3o98.png" alt=""></p>
<h3 id="Backward"><a href="#Backward" class="headerlink" title="Backward"></a>Backward</h3><p>最普通的图片能量计算方式——求偏导。利用有限差分求出gradient maltitude能量图。</p>
<h3 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h3><p>作者认为在寻找Seam的问题中，我们不仅要考虑删除后对原图像的影响(即backward),还要考虑当删除后产生的新的“伪影”的影响。因此Forward的目的是找到产生“伪影”最少的能量图。</p>
<p><img src="https://p.ipic.vip/rx1jqg.png" alt=""></p>
<p><img src="https://p.ipic.vip/189ivz.png" alt=""></p>
<p><img src="https://p.ipic.vip/n5bn2c.png" alt=""></p>
<p>最终我们发现Forward和SR的结合得到的能量图效果最好</p>
<h2 id="迭代次数"><a href="#迭代次数" class="headerlink" title="迭代次数"></a>迭代次数</h2><p>理论上，由于遗传算法属于广域搜索，迭代次数接近无穷时便能得到最优结果。但其缺点也是时间代价过高，如GA方法和warping方法的对比：</p>
<p><img src="https://p.ipic.vip/34m9ex.png" alt=""></p>
<p>我们也确认了当迭代次数增加时，能量损失会下降更多，效果也会更好</p>
<p><img src="https://p.ipic.vip/p8u1c0.png" alt=""></p>
<p><img src="https://p.ipic.vip/02bb0u.png" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对比，我们发现比起warping手法，GA手法确实更容易找到全局最优（体现在GA的结果的图片中更能凸显主体）；但是对应的，GA手法耗费时间更长，并且由于是离散算法导致可能出现像素锯齿，影响图片质量。</p>
<p><img src="https://p.ipic.vip/l5538q.png" alt=""></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/llsf9/cgo-group-work">https://github.com/llsf9/cgo-group-work</a></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Saulo AF Oliveira, Francisco N Bezerra, and Ajalmar R Rocha Neto. 2015. Genetic seam carving: A genetic algorithm approach for content-aware image retargeting. In Iberian Conference on Pattern Recognition and Image Analysis. Springer, 700–707. </p>
<p>[2] Yu-Shuen Wang, Chiew-Lan Tai, Olga Sorkine, and Tong-Yee Lee. 2008. Optimized scale-and-stretch for image resizing. In ACM SIGGRAPH Asia 2008 papers. 1–8.</p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>CGO</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS总结</title>
    <url>/2020/03/10/css-memo/</url>
    <content><![CDATA[<h2 id="一-基础属性"><a href="#一-基础属性" class="headerlink" title="一 基础属性"></a>一 基础属性</h2><h3 id="连接css"><a href="#连接css" class="headerlink" title="连接css"></a>连接css</h3><ul>
<li>内联式<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:red;font-size:12px;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>嵌入式<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>:<span class="number">12px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>外部式<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;base.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<em>一般写在head</em></li>
</ul>
<p><u>优先级：内联式 &gt; 嵌入式 &gt; 外部式</u></p>
<hr>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="1-基本选择器"><a href="#1-基本选择器" class="headerlink" title="1. 基本选择器"></a>1. 基本选择器</h4><ul>
<li><p>标签选择器：选出所有相同的标签。但无法差异化选择。</p>
</li>
<li><p>:star: 类选择器：class。最常用的选择器。多个元素可以用一个class，一个元素也可以有多个class</p>
<ol>
<li><p>多类名</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red font20&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以在同个class属性中写多个类名，但中间要用空格隔开</p>
<p><em>应用场景：共通的样式可以放到同个class，然后再设置各自单独的class，从而方便修改。</em></p>
</li>
</ol>
</li>
<li><p>id选择器：只能使用一次。</p>
</li>
</ul>
<h4 id="2-复合选择器"><a href="#2-复合选择器" class="headerlink" title="2. 复合选择器"></a>2. 复合选择器</h4><ul>
<li><p>后代选择器</p>
<p><code>元素1 元素2</code></p>
<p>空格。选择所有后代。不只是第一代。</p>
</li>
<li><p>子代选择器</p>
<p><code>元素1&gt;元素2</code><br>大于符号(&gt;),用于选择指定标签元素的第一代子元素。</p>
<p>（第一代子元素：指定标签中包含的直系子元素。）</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">	<span class="selector-class">.first</span>&gt;<span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="language-css">		<span class="attribute">border</span>:<span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">	&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!--例 1--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span>三年级时，<span class="tag">&lt;<span class="name">span</span>&gt;</span>我还是一个<span class="tag">&lt;<span class="name">span</span>&gt;</span>胆小如鼠<span class="tag">&lt;/<span class="name">span</span>&gt;</span>的小女孩<span class="tag">&lt;/<span class="name">span</span>&gt;</span>，上课从来不敢</span><br><span class="line">回答老师提出的问题。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--此例虽有两个span，但为包含关系，第二个span为第二代子元素。因此只    对第一个span起作用。即结果为“我</span></span><br><span class="line"><span class="comment">还是一个胆小如鼠的小女孩”被框选--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--例 2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span>三年级时，<span class="tag">&lt;<span class="name">span</span>&gt;</span>我还是一个<span class="tag">&lt;/<span class="name">span</span>&gt;</span>胆小如鼠<span class="tag">&lt;<span class="name">span</span>&gt;</span>的小女孩<span class="tag">&lt;/<span class="name">span</span>&gt;</span>，上课从来不敢</span><br><span class="line">回答老师提出的问题。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--此例也有两个span，但为独立关系，两个span均为第一代子元素。因此两个span均起作用。即结果为“我</span></span><br><span class="line"><span class="comment">还是一个”和“的小女孩”被框选--&gt;</span> </span><br></pre></td></tr></table></figure>
<ul>
<li><p>包含选择器<br>即加入空格,用于选择指定标签元素下的后辈元素。<br>如子选择器的例1，如果改为包含选择器，则“我还是一个胆小如鼠的小女孩”和“胆小如鼠”均被框选。</p>
</li>
<li><p>通配符选择器<br>使用一个（<em>）号指定，它的作用是匹配html中所有标签元素。<br>**用\</em>会消耗CPU，因为浏览器需要找出所有标签，并给它们都加上修饰。**</p>
</li>
<li><p>伪类选择器</p>
<ol>
<li><p>链接伪类选择器</p>
<ul>
<li>a:link：选择所有未被访问的链接</li>
<li>a:visited：选择所有已被访问的链接</li>
<li>a:hover：选择鼠标指针位于上面的链接</li>
<li>a:active：选择活动链接（鼠标按下还未弹起的链接）</li>
</ul>
<p>注意事项：</p>
<ol>
<li>为保证效果，按照link-visited-hover-active的顺序声明（LVHA）</li>
<li>链接与标题类似，要单独设置样式</li>
<li>平时一般只定义a的颜色和a:hover的颜色，其他不常用</li>
</ol>
</li>
<li><p>表单伪类选择器</p>
<ol>
<li>input:focus：选择获取了焦点（光标）的input表单元素</li>
</ol>
</li>
</ol>
</li>
<li><p>并集选择器<br>使用逗号<code>,</code>，为多个标签元素设置同一个样式。</p>
<ol>
<li>摒弃选择器的语法规范：竖着写</li>
</ol>
</li>
</ul>
<hr>
<h3 id="字体属性"><a href="#字体属性" class="headerlink" title="字体属性"></a>字体属性</h3><h4 id="1-属性总结"><a href="#1-属性总结" class="headerlink" title="1. 属性总结"></a>1. 属性总结</h4><ul>
<li><p>font-size: 字号</p>
<ol>
<li>标题文字比较特殊，需要单独设置大小</li>
<li>各浏览器默认文字大小不同，尽量指定准确像素值</li>
</ol>
</li>
<li><p>font-weight: 字体粗细</p>
<ol>
<li><p>bold: 加粗 </p>
</li>
<li><p>:star: 直接写不带单位的数字，可以自定义粗体效果700=bold</p>
<p>400=normal</p>
</li>
</ol>
</li>
<li><p>font-family: 字体样式</p>
<ol>
<li>不同字体样式用逗号分隔</li>
<li>中文或有空格的英文要引号包起来</li>
</ol>
</li>
<li><p>font-style: 文字样式</p>
<ol>
<li>italic: 斜体</li>
<li>normal: 默认标准样式</li>
<li>主要不是用来加斜体，而是让斜体变为默认</li>
</ol>
</li>
</ul>
<h4 id="2-复合写法"><a href="#2-复合写法" class="headerlink" title="2. 复合写法"></a>2. 复合写法</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font</span>: font-style font-weight font-size/line-height font-family;</span><br></pre></td></tr></table></figure>
<ol>
<li>绝对不能颠倒顺序<ol>
<li>中间用空格间隔</li>
<li>不需要的属性可以省略，但是font-size和font-family必须保留，否则将不起作用。</li>
</ol>
</li>
</ol>
<hr>
<h3 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h3><h4 id="1-属性总结-1"><a href="#1-属性总结-1" class="headerlink" title="1. 属性总结"></a>1. 属性总结</h4><ul>
<li><p>color: 文本颜色</p>
<ol>
<li>:star: 十六进制: #➕颜色代码</li>
<li>预定义的颜色值: 英文颜色名</li>
<li>RGB代码: rgb()</li>
</ol>
</li>
<li><p>text-align: 对齐文本</p>
<ol>
<li>只能水平对齐</li>
<li>本质是让盒子里的文字在盒子里居中对齐。因此对齐效果取决于盒子的大小。</li>
</ol>
</li>
<li><p>text-decoration: 装饰文本</p>
<ol>
<li><p>none: 默认无装饰线（最常用，用来给a标签去掉默认的下划线）</p>
</li>
<li><p>underline: 下划线（常用）</p>
</li>
<li><p>line-through: 删除线（不常用）</p>
</li>
<li>overline: 上划线（几乎不用）</li>
</ol>
</li>
<li><p>text-indent: 文本缩进</p>
<ol>
<li>“数字+px”，缩进规定像素</li>
<li>:star: “数字+em”，缩进相对当前文字大小的文字个数</li>
</ol>
</li>
<li><p>line-height: 行间距</p>
<ol>
<li><strong>行间距=上间距+文本高度+下间距</strong>。当行间距设置为26且文本为默认大小时，26-16=10，上间距+下间距=10</li>
<li>“数字+px”</li>
</ol>
</li>
<li><p>letter-spacing 字母间距（中文文字间距）</p>
<ol>
<li>后接“数字+px”</li>
</ol>
</li>
<li><p>word-spacing 单词间距</p>
<ol>
<li>后接“数字+px”</li>
</ol>
</li>
</ul>
<h4 id="2-文字单位"><a href="#2-文字单位" class="headerlink" title="2. 文字单位"></a>2. 文字单位</h4><p><em>px, em ,%均为相对单位</em></p>
<ul>
<li><p>px:相对屏幕像素点</p>
</li>
<li><p>em:</p>
<ol>
<li>相对此元素的font-size。如此时字体为14px，那么首行缩进若设置2em即缩进2个14px的大小。即1em=14px。</li>
<li>若将em应用于font-size，那么是相对于父元素的的font-size。</li>
</ol>
</li>
<li><p>%:相对此元素的font-size。</p>
</li>
</ul>
<hr>
<h3 id="背景样式"><a href="#背景样式" class="headerlink" title="背景样式"></a>背景样式</h3><h4 id="1-背景颜色"><a href="#1-背景颜色" class="headerlink" title="1. 背景颜色"></a>1. 背景颜色</h4><p><code>background-color</code></p>
<ul>
<li>默认属性值为transparent，透明色</li>
</ul>
<h4 id="2-背景图片"><a href="#2-背景图片" class="headerlink" title="2. 背景图片"></a>2. 背景图片</h4><p><code>background-image</code></p>
<ul>
<li><p>常用于logo和装饰性图片，或者是超大的背景图</p>
</li>
<li><p>比起img直接插入，背景图更加易于控制位置</p>
</li>
<li><p>背景图片和背景颜色可以同时存在，但是图片会压着颜色</p>
</li>
<li><p>属性值：</p>
<ul>
<li>none（默认）</li>
<li>url()</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">images/logo.jpg</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-背景平铺"><a href="#3-背景平铺" class="headerlink" title="3. 背景平铺"></a>3. 背景平铺</h4><p><code>background-repeat</code></p>
<ul>
<li>属性值：<ul>
<li>repeat（默认）</li>
<li>no-repeat</li>
<li>repeat-x（只在横向平铺）</li>
<li>repeat-y（只在纵向平铺）</li>
</ul>
</li>
</ul>
<h4 id="4-背景图片位置"><a href="#4-背景图片位置" class="headerlink" title="4. 背景图片位置"></a>4. 背景图片位置</h4><p><code>background-position</code></p>
<ul>
<li><p>属性值</p>
<ul>
<li><p>方位名词，如：</p>
<ol>
<li>center right（右中）</li>
<li>left top（左上）</li>
<li>top center（上中）</li>
</ol>
<p>注意：</p>
<ol>
<li>两个方位都写的话无顺序要求</li>
<li>只写一个方位时，另一个方位默认居中</li>
</ol>
</li>
<li><p>精确单位</p>
<ol>
<li>x,y的顺序不能颠倒</li>
<li>如果只指定一个数值，那一定是x值，y为居中</li>
<li>坐标原点为左上角</li>
</ol>
</li>
<li><p>混合单位</p>
<ol>
<li>x,y的顺序不能颠倒</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="5-背景图像固定（背景附着）"><a href="#5-背景图像固定（背景附着）" class="headerlink" title="5. 背景图像固定（背景附着）"></a>5. 背景图像固定（背景附着）</h4><p><code>background-attachment</code></p>
<ul>
<li>属性值<ul>
<li>scroll(默认)：随着滚轮滚动背景图</li>
<li>fixed:固定背景图</li>
</ul>
</li>
</ul>
<h4 id="6-star-背景复合写法"><a href="#6-star-背景复合写法" class="headerlink" title="6.:star: 背景复合写法"></a>6.:star: 背景复合写法</h4><p><code>background</code></p>
<ul>
<li>无强制要求书写顺序</li>
<li>:star: 约定俗成的顺序为：颜色-图片地址-平铺-图像固定-图片位置</li>
<li>中间用空格隔开</li>
</ul>
<h4 id="7-背景颜色半透明-CSS3"><a href="#7-背景颜色半透明-CSS3" class="headerlink" title="7. 背景颜色半透明(CSS3)"></a>7. 背景颜色半透明(CSS3)</h4><p><code>background:rgba(0,0,0,0.3);</code></p>
<ul>
<li>最后一个参数为阿尔法透明度，取值范围为0~1，0为完全透明，1为完全不透明</li>
<li>前面的颜色rgb不一定为0可以自己改</li>
<li>不影响盒子里的内容</li>
</ul>
<hr>
<h3 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h3><h4 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h4><p>样式不仅应用于某个特定html标签元素，而且应用于其后代（包含的所有元素)。</p>
<ul>
<li>文字样式都能继承</li>
<li>高度宽度等盒子样式一般不会继承</li>
</ul>
<p>行间距的继承：</p>
<ul>
<li>父元素行间距设置为24px或者2em等带单位时，后代元素即使更改了字体大小，仍然是按父元素的字体大小比例计算</li>
<li>父元素行间距设置为2，不带单位时，后代元素即使更改了字体大小，也会按照自己的字体大小比例计算</li>
<li><u>结论；当想让子元素根据自身的字体大小自动调整行高时，父元素的行间距不要带单位</u></li>
</ul>
<h4 id="2-权值"><a href="#2-权值" class="headerlink" title="2. 权值"></a>2. 权值</h4><p>浏览器根据权值来判断使用哪种css样式的，权值高的就使用哪种css样式。<br>权值如下：</p>
<ul>
<li>继承或者是*；0,0,0,0</li>
<li>元素选择器：0,0,0,1</li>
<li>类选择器，伪类选择器：0,0,1,0</li>
<li>ID选择器：0,1,0,0</li>
<li>行内样式style：1,0,0,0</li>
<li>!important：约等于无穷大</li>
</ul>
<p>权值叠加：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red;&#125; <span class="comment">/*权值为1*/</span></span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span>&#123;<span class="attribute">color</span>:green;&#125; <span class="comment">/*权值为1+1=2*/</span></span><br><span class="line"><span class="selector-class">.warning</span>&#123;<span class="attribute">color</span>:white;&#125; <span class="comment">/*权值为10*/</span></span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span><span class="selector-class">.warning</span>&#123;<span class="attribute">color</span>:purple;&#125; <span class="comment">/*权值为1+1+10=12*/</span></span><br><span class="line"><span class="selector-id">#footer</span> <span class="selector-class">.note</span> <span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:yellow;&#125; <span class="comment">/*权值为100+10+1=111*/</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>权值永远不会进位（类选择器再叠加也不会超过ID选择器的权重）</li>
<li>等级判断从左往右，如果某一位数值相同，则判断下一位数值</li>
<li>浏览器默认的样式相当于元素选择器，权重大于继承。因此对于链接和标题这种有默认样式的我们必须单独设置。</li>
</ol>
<h4 id="3-层叠"><a href="#3-层叠" class="headerlink" title="3. 层叠"></a>3. 层叠</h4><p>对于同一个元素有多个css样式存在时</p>
<ol>
<li>样式权重相同时，用靠后的</li>
<li>相同的样式才会层叠，如果其中有不冲突的样式依旧正常执行</li>
</ol>
<h4 id="4-important"><a href="#4-important" class="headerlink" title="4. important"></a>4. important</h4><p><code>!important</code>为某些样式设置具有最高权值。<br><strong>一般样式优先级为：浏览器默认的样式 &lt; 网页制作者样式 &lt; 用户自己设置的样式，但!important优先级样式会使权值高于用户自己设置的样式，因此要谨慎使用。</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">color</span>:red<span class="meta">!important</span>;&#125;<span class="comment">/*注意：!important要写在分号的前面*/</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h3><h4 id="1-块级元素"><a href="#1-块级元素" class="headerlink" title="1. 块级元素"></a>1. 块级元素</h4><p><strong>例如</strong>：<code>&lt;div&gt;,&lt;p&gt;、&lt;h1&gt;、&lt;form&gt;、&lt;ul&gt; 和 &lt;li&gt;</code></p>
<p>特点：</p>
<ol>
<li><p>独占一行</p>
</li>
<li><p>元素的高度、宽度、行高以及顶和底边距都可设置。</p>
<ol>
<li>元素宽度默认是它本身父容器的100%（和父元素的宽度一致）</li>
</ol>
</li>
<li>是一个容器或合资<ol>
<li>文字类里不能再放块级元素</li>
<li>:star:<strong>转换</strong>：将内联元素转换为块状元素<br><code>a&#123;display:block;&#125;</code></li>
</ol>
</li>
</ol>
<h4 id="2-内联元素（行内元素）"><a href="#2-内联元素（行内元素）" class="headerlink" title="2. 内联元素（行内元素）"></a>2. 内联元素（行内元素）</h4><p>  <strong>例如</strong>：<code>&lt;span&gt;、&lt;a&gt;、&lt;label&gt;、 &lt;strong&gt; 和&lt;em&gt;</code><br>  <strong>特点</strong>：</p>
<ol>
<li>和其他元素都在一行上；</li>
<li>元素的高度、宽度及顶部和底部边距不可设置；</li>
<li>元素的默认宽度就是它包含的文字或图片的宽度，不可改变。</li>
<li>行内元素只能容纳文本或者其他行内元素。只有a特殊可以放块级元素。</li>
<li><strong>转换</strong>:将元素div转换为内联块状元素<br><code>display:inline;</code></li>
</ol>
<h4 id="3-内联块状元素"><a href="#3-内联块状元素" class="headerlink" title="3. 内联块状元素"></a>3. 内联块状元素</h4><p>  <strong>例如</strong>：<code>\&lt;img&gt;、\&lt;input&gt;</code><br>  <strong>特点</strong>：</p>
<ol>
<li>和其他元素都在一行上。中间有空白缝隙。</li>
<li>默认宽度为包含内容的宽度。</li>
<li>元素的高度、宽度、行高以及顶和底边距都可设置。</li>
<li><strong>转换</strong>:将元素div转换为内联块状元素<ol>
<li>:star:<code>display:inline-block;</code></li>
<li>float和position：absolute会隐形改变任何元素为内联块状元素</li>
</ol>
</li>
</ol>
<hr>
<h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><h4 id="1-内联元素"><a href="#1-内联元素" class="headerlink" title="1. 内联元素"></a>1. 内联元素</h4><ul>
<li>给父元素设置 <code>text-align:center</code></li>
</ul>
<h4 id="2-块状元素"><a href="#2-块状元素" class="headerlink" title="2. 块状元素"></a>2. 块状元素</h4><ul>
<li><p>利用外边距让盒子水平居中</p>
<p>前提条件：</p>
<ol>
<li>已设置了宽度</li>
</ol>
<p>方法：</p>
<ol>
<li>让左右margin设置为auto</li>
</ol>
</li>
</ul>
<ul>
<li>不定宽块状元素<br>1.放入table标签中。将table的margin属性设为auto。（因table有自动调节功能）<br>2.利用display转换为内联元素，利用内联元素的居中方法。<br>3.通过给父元素设置float，然后给父元素设置 position:relative和 left:50%（此时父元素左侧正好位于页面中轴线），子元素设置 position:relative 和 left: -50% 来实现水平居中（利用父元素和子元素宽度相同，使子元素中轴线在父元素最左侧，即子元素的中轴线与页面中轴线重合）。<a href="https://www.imooc.com/qadetail/296850">不理解如何达到居中效果</a></li>
</ul>
<hr>
<h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><h4 id="1-父元素高度确定的单行文本"><a href="#1-父元素高度确定的单行文本" class="headerlink" title="1. 父元素高度确定的单行文本"></a>1. 父元素高度确定的单行文本</h4><p>通过设置父元素的 height 和line-height（行间距）高度一致</p>
<p>原理：</p>
<p>​    行间距=上间距+文字高度+下间距，一旦等于盒子高度，上下间距正好相同，文字就垂直居中了</p>
<p>同理，如果想稍微偏上居中，可以把行间距略小于盒子高度</p>
<h4 id="2-父元素高度确定的多行文本"><a href="#2-父元素高度确定的多行文本" class="headerlink" title="2. 父元素高度确定的多行文本"></a>2. 父元素高度确定的多行文本</h4><ol>
<li>利用table.同时设置 vertical-align：middle。（因td默认不用设置）<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">table</span> <span class="selector-tag">td</span>&#123;<span class="attribute">height</span>:<span class="number">500px</span>;<span class="attribute">background</span>:<span class="number">#ccc</span>&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tbody</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>看我是否可以居中。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>设置块级元素的 display 为 table-cell（设置为表格单元显示），并设置vertical-align 属性。（此方法会将块级元素隐形改变为内联元素）。</li>
</ol>
<hr>
<h2 id="二-盒子模型"><a href="#二-盒子模型" class="headerlink" title="二 盒子模型"></a>二 盒子模型</h2><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><h4 id="1-边框粗细"><a href="#1-边框粗细" class="headerlink" title="1. 边框粗细"></a>1. 边框粗细</h4><p><code>border-width</code></p>
<ul>
<li>一般用px单位</li>
</ul>
<h4 id="2-边框样式"><a href="#2-边框样式" class="headerlink" title="2. 边框样式"></a>2. 边框样式</h4><p><code>border-style</code></p>
<p>属性值</p>
<ul>
<li>solid：实线边框</li>
<li>dashed：虚线边框</li>
<li>dotted：点状边框</li>
</ul>
<h4 id="3-边框颜色"><a href="#3-边框颜色" class="headerlink" title="3. 边框颜色"></a>3. 边框颜色</h4><p><code>border-color</code></p>
<h4 id="4-复合写法"><a href="#4-复合写法" class="headerlink" title="4. 复合写法"></a>4. 复合写法</h4><ol>
<li><p>综合写法</p>
<p><code>border:border-width border-style border-color</code></p>
<ul>
<li>无强制要求顺序</li>
<li>约定俗成的顺序为粗细-样式-颜色</li>
</ul>
</li>
<li><p>单独写法</p>
<ul>
<li><code>border-top</code></li>
<li><code>border-right</code></li>
<li><code>border-bottom</code></li>
<li><code>border-left</code></li>
</ul>
</li>
</ol>
<h4 id="5-边框合并"><a href="#5-边框合并" class="headerlink" title="5. 边框合并"></a>5. 边框合并</h4><p><code>border-collapse</code></p>
<p>属性值：</p>
<ul>
<li>collapse:将相邻的边框合并</li>
</ul>
<h4 id="6-边框相关注意事项"><a href="#6-边框相关注意事项" class="headerlink" title="6.边框相关注意事项"></a>6.边框相关注意事项</h4><ol>
<li>边框会影响盒子的大小：在盒子外包了一层边框，因此盒子会变大</li>
</ol>
<hr>
<h3 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h3><p><code>padding</code></p>
<p>边框与内容的距离</p>
<ol>
<li><p>属性总结：</p>
<ul>
<li><code>padding-top</code></li>
<li><code>padding-right</code></li>
<li><code>padding-bottom</code></li>
<li><code>padding-left</code></li>
</ul>
</li>
<li><p>复合属性</p>
<ol>
<li><p>1个值：上下左右都为一个值</p>
<p><code>padding=5px;</code></p>
</li>
<li><p>2个值：上下一个值 左右一个值</p>
<p><code>padding=5px 10px;</code></p>
</li>
<li><p>3个值：上一个值 左右一个值 下一个值</p>
<p><code>padding=5px 10px 20px;</code></p>
</li>
<li><p>4个值：上一个值 右一个值 下一个值 左一个值</p>
<p><code>padding=5px 10px 20px 30px;</code></p>
</li>
</ol>
</li>
<li><p>注意事项</p>
<ol>
<li><p>指定高宽时会影响盒子大小，撑大盒子</p>
<p>解决方法：减小盒子的宽和高</p>
</li>
<li><p>不指定高宽时不会影响盒子大小</p>
</li>
</ol>
</li>
</ol>
<hr>
<h3 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h3><p><code>margin</code></p>
<p>外边距。盒子和盒子的距离。</p>
<ol>
<li><p>属性总结</p>
<ul>
<li><p><code>margin-top</code></p>
</li>
<li><p><code>margin-right</code></p>
</li>
<li><p><code>margin-bottom</code></p>
</li>
<li><p><code>margin-left</code></p>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>复合属性</p>
<p>和padding复合属性完全相同</p>
</li>
</ol>
<ol>
<li><p>利用外边距让盒子水平居中</p>
<p>前提条件：</p>
<ol>
<li>已设置了宽度</li>
</ol>
<p>方法：</p>
<ol>
<li>让左右margin设置为auto</li>
</ol>
</li>
</ol>
<ol>
<li><p>外边距合并</p>
<ol>
<li><p>相邻块元素垂直外边距的合并</p>
<p>效果：取两值较大者</p>
<blockquote>
<p>如上面有个块元素1，下面有个块元素2，为垂直关系。块元素1的下margin为100，而块元素2的上margin为200时，两个块元素间的距离为200</p>
</blockquote>
<p>解决方法：尽量只给一个盒子添加margin</p>
</li>
<li><p>嵌套块元素垂直外边距的塌陷</p>
<p>效果：取两值较大者</p>
<blockquote>
<p>如有个父块元素，里面有个子块元素，为父子关系。父块元素的上margin为50，而子块元素的上margin为100时，两个块元素间的距离为100</p>
</blockquote>
<p>解决方法：</p>
<ol>
<li>为父元素添加一个边框（为保证效果可以做成transparent边框）</li>
<li>为父元素添加padding</li>
<li>为父元素添加overflow:hidden</li>
<li>子盒子增加浮动</li>
</ol>
</li>
</ol>
</li>
<li><p>清除内外边距</p>
<p>不同浏览器默认内外边距不同，因此我们布局前要先清除内外边距。一般使用通配符*</p>
<p>注意：</p>
<p>行内元素为照顾兼容性只设置左右外边距。但是块元素和行内块元素可以随意设置。 </p>
</li>
</ol>
<hr>
<h3 id="CSS3新增样式"><a href="#CSS3新增样式" class="headerlink" title="CSS3新增样式"></a>CSS3新增样式</h3><h4 id="1-圆角边框"><a href="#1-圆角边框" class="headerlink" title="1. 圆角边框"></a>1. 圆角边框</h4><p><code>border-radius</code></p>
<ul>
<li><p>属性值：</p>
<ul>
<li>px为单位的数值</li>
<li>百分比</li>
</ul>
</li>
<li><p>原理：</p>
<p>​    调出四个数值同大小半径的圆，与矩形结合。因此数值越大，弧度越明显</p>
</li>
<li><p>使用：</p>
<ol>
<li>圆形：<ol>
<li>数值=正方形的边长的一半</li>
<li>百分比=50%</li>
</ol>
</li>
<li>圆角矩形：<ol>
<li>数值=矩形高度的一半</li>
</ol>
</li>
</ol>
</li>
<li><p>复合写法</p>
<ol>
<li><p>四个数值</p>
<p><code>border-radius：左上角 右上角 右下角 左下角</code></p>
</li>
<li><p>两个数值</p>
<p><code>border-radius:左上角及其对角 右上角及其对角</code></p>
</li>
</ol>
</li>
<li><p>单独写法</p>
<ul>
<li><code>border-top-left-radius</code></li>
<li><code>border-top-right-radius</code></li>
<li><code>border-bottom-left-radius</code></li>
<li><code>border-bottom-right-radius</code></li>
</ul>
</li>
</ul>
<h4 id="2-盒子阴影"><a href="#2-盒子阴影" class="headerlink" title="2. 盒子阴影"></a>2. 盒子阴影</h4><p><code>box-shadow：h-shadow v-shadow blur spread color inset</code></p>
<ul>
<li><p>属性：</p>
<ul>
<li>h-shadow:必须，水平阴影的位置，允许负值。以左上角为坐标原点，正为右，负为左。</li>
<li>v-shadow:必须，水平阴影的位置，允许负值。正为下，负为上。</li>
<li>blur:可选。模糊距离。越大边缘阴影越模糊。</li>
<li>spread:可选，阴影尺寸。影子大小。</li>
<li>color:可选。阴影颜色。一般用rgba(0,0,0,0.3)，黑色半透明。</li>
<li>inset:可选。改为内阴影。</li>
</ul>
</li>
<li><p>注意：</p>
<ol>
<li>盒子阴影不占用空间。</li>
</ol>
</li>
<li><p>使用：</p>
<ol>
<li><p>鼠标经过出现影子效果</p>
<p>:hover</p>
<p>不只是链接元素，盒子元素（div等）也可以使用</p>
</li>
</ol>
</li>
</ul>
<h4 id="3-文字阴影"><a href="#3-文字阴影" class="headerlink" title="3. 文字阴影"></a>3. 文字阴影</h4><p><code>text-shadow:h-shadow v-shadow blur color</code></p>
<ul>
<li>属性：<ul>
<li>h-shadow:必须，水平阴影的位置，允许负值。以左上角为坐标原点，正为右，负为左。</li>
<li>v-shadow:必须，水平阴影的位置，允许负值。正为下，负为上。</li>
<li>blur:可选。模糊距离。越大边缘阴影越模糊。</li>
<li>color:可选。阴影颜色。  </li>
</ul>
</li>
</ul>
<hr>
<h2 id="三-浮动"><a href="#三-浮动" class="headerlink" title="三 浮动"></a>三 浮动</h2><h3 id="1-传统网页布局的三种方式"><a href="#1-传统网页布局的三种方式" class="headerlink" title="1. 传统网页布局的三种方式"></a>1. 传统网页布局的三种方式</h3><blockquote>
<p>实际开发中，一个网页基本都要用到这三个布局</p>
</blockquote>
<ol>
<li><p>标准流（普通流/文档流）</p>
<p><u>标签按照规定好的默认方式排列</u></p>
<ul>
<li><p>特性：</p>
<ol>
<li><p>块级元素独占一行，从上到下按顺序排列</p>
</li>
<li><p>行内元素从左到右按顺序排列</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>浮动（float）</p>
<p><code>float</code></p>
<p>创建浮动框，使其移动到一边，直到左边缘或者右边缘触及包含块或另一个浮动框的边缘</p>
<ul>
<li><p>属性值</p>
<ul>
<li>none：不浮动</li>
<li>left：左浮动</li>
<li>right：右浮动</li>
</ul>
</li>
<li><p>特性</p>
<ol>
<li>浮动的元素会脱离标准流（脱标）</li>
<li>浮动的盒子不再保留原先的位置（后面的标准流会上来顶上位置）</li>
<li>浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流（虽然后面的标准流会上来被压在浮动下，浮动却无法飘到上面的标准流上）</li>
<li>如果多个盒子都设置了浮动，则他们会按照属性值一行内显示并且顶端对齐</li>
<li>如果父元素宽度放不下，对出来的会自动换行</li>
<li>浮动元素会有行内块元素的特点（与原元素无关）：1.可以设置宽高 2.显示</li>
<li>与行内块不同之处：行内块之间会有缝隙，浮动元素没有</li>
</ol>
</li>
<li><p>注意</p>
<ol>
<li><p>浮动元素经常和标准流父级搭配使用：</p>
<p>为了约束浮动元素的位置，我们一般先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置</p>
</li>
<li><p>一个元素浮动了，理论上其余的兄弟元素也要浮动，以防出现问题</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>定位</p>
</li>
</ol>
<h3 id="2-网页布局准则"><a href="#2-网页布局准则" class="headerlink" title="2. 网页布局准则"></a>2. 网页布局准则</h3><ol>
<li>多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动</li>
<li>先设置盒子大小，再设置盒子的位置</li>
</ol>
<h3 id="3-清除浮动"><a href="#3-清除浮动" class="headerlink" title="3. 清除浮动"></a>3. 清除浮动</h3><h4 id="1-原因"><a href="#1-原因" class="headerlink" title="1. 原因"></a>1. 原因</h4><p>父级盒子很多情况下不方便给高度，但是盒子浮动不占用位置，会导致</p>
<ol>
<li>父级盒子高度为0</li>
<li>影响下面的标准流盒子</li>
</ol>
<h4 id="2-本质"><a href="#2-本质" class="headerlink" title="2. 本质"></a>2. 本质</h4><ol>
<li>清除浮动元素造成的影响</li>
<li>如果父级本身有高度，则不需要清除浮动</li>
</ol>
<h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h4><p><code>clear</code></p>
<ul>
<li><p>属性值</p>
<ul>
<li>left：清除左浮动的影响</li>
<li>right：清除右浮动的影响</li>
<li>both：清除左右浮动的影响</li>
</ul>
</li>
<li><p>注意</p>
<ol>
<li>实际开发中几乎只用both</li>
<li>策略为闭合浮动</li>
</ol>
</li>
<li><p>使用</p>
<ol>
<li><p>额外标签法</p>
<p><code>&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;</code></p>
<p>在浮动元素末尾添加一个空块级标签</p>
<ol>
<li>优点：通俗易懂</li>
<li>缺点：添加无意义标签，结构性差</li>
</ol>
</li>
<li><p>父级添加overflow</p>
<p><code>overflow:hidden|auto|scroll</code></p>
<p>为父级添加overflow任意属性值，<u>开发中常用的是hidden</u></p>
<ol>
<li>优点：代码简洁</li>
<li>缺点：无法显示子元素溢出部分</li>
</ol>
</li>
<li><p>:after伪元素法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">  <span class="attribute">visibility</span>:hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;<span class="comment">/*IE6，7专有*/</span></span><br><span class="line">  *zoom:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clearfix为父盒子的class名</p>
<ol>
<li>优点：没有增加标签，结构简单</li>
<li>缺点：需要照顾低版本</li>
</ol>
</li>
<li><p>双伪元素法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-class">.before</span>, <span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  *zoom:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clearfix为父盒子的class名</p>
<ol>
<li>优点：代码更简洁了</li>
<li>缺点：需要照顾低版本</li>
</ol>
</li>
</ol>
</li>
</ul>
<h4 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h4><ol>
<li>父元素没有高度</li>
<li>子盒子浮动了</li>
<li>影响下面布局了</li>
</ol>
<h2 id="四-定位"><a href="#四-定位" class="headerlink" title="四 定位"></a>四 定位</h2><h2 id="五-PS切图"><a href="#五-PS切图" class="headerlink" title="五 PS切图"></a>五 PS切图</h2><h3 id="1-图层切图"><a href="#1-图层切图" class="headerlink" title="1. 图层切图"></a>1. 图层切图</h3><ol>
<li>导出图片</li>
<li>合并图层</li>
</ol>
<h3 id="2-切片切图"><a href="#2-切片切图" class="headerlink" title="2. 切片切图"></a>2. 切片切图</h3><ol>
<li>导出图片</li>
<li>导出透明图片：关闭背景-选中png格式</li>
</ol>
<h3 id="3-插件切图Cutterman"><a href="#3-插件切图Cutterman" class="headerlink" title="3. 插件切图Cutterman"></a>3. 插件切图Cutterman</h3><ol>
<li>导出图片</li>
<li>合并图层</li>
<li>导出选区</li>
</ol>
<h2 id="六-书写相关"><a href="#六-书写相关" class="headerlink" title="六 书写相关"></a>六 书写相关</h2><h3 id="CSS属性书写顺序"><a href="#CSS属性书写顺序" class="headerlink" title="CSS属性书写顺序"></a>CSS属性书写顺序</h3><ol>
<li>布局定位属性</li>
<li>自身属性</li>
<li>文本属性</li>
<li>其他属性</li>
</ol>
<h5 id="流动模型（flow）"><a href="#流动模型（flow）" class="headerlink" title="流动模型（flow）"></a>流动模型（flow）</h5><p>默认的网页布局模式。</p>
<ol>
<li>块级元素垂直分布</li>
<li>内联元素水平分布<h5 id="浮动模型（float）"><a href="#浮动模型（float）" class="headerlink" title="浮动模型（float）"></a>浮动模型（float）</h5>使块级元素脱离默认的流动模型，浮于其他块级元素的上层。其他元素不受影响继续按照流动模型排版。但不会影响内联元素，内联元素依旧被挤走。因此可实现<strong>文字环绕图片效果</strong>。<a href="https://blog.csdn.net/huhaha24/article/details/79680556">关于float浮动的通俗理解</a></li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">float</span><span class="selector-pseudo">:left</span>;&#125;//左浮动</span><br><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">float</span><span class="selector-pseudo">:right</span>;&#125;//右浮动</span><br></pre></td></tr></table></figure>
<h5 id="层模型"><a href="#层模型" class="headerlink" title="层模型"></a>层模型</h5><p>1.绝对定位<br>相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。<br>绝对定位将块级元素从默认模型拉出来，使其位于默认模型和浮动模型之上。<br>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">top</span>:;</span><br><span class="line">  <span class="attribute">right</span>:;</span><br><span class="line">  <span class="attribute">left</span>:;</span><br><span class="line">  <span class="attribute">bottom</span>:;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="http://img.mukewang.com/53a00b130001e86707360547.jpg" alt="绝对定位"><br>2.相对定位<br>首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。</p>
<ul>
<li><code>position:relative</code></li>
<li>相对于以前的位置移动：属性确定的是以移动后的元素为主体，观察以前的位置。如<code>right:50px</code>会把块级元素向左移动50px，因为浏览器观察到以前的元素是在右边50px。<br><strong><em>（个人理解：relative属性相当于形成了一个以此元素为原点的坐标系）</em></strong></li>
<li>偏移前的位置保留不动：虽然div元素相对于以前的位置产生了偏移，但是div元素以前的位置还是保留着，所以后面的span元素是显示在了div元素以前位置的后面。<br><img src="http://img.mukewang.com/53a00d2b00015c4b06190509.jpg" alt="相对定位"><br>3.固定定位<br>小广告定位：相对移动的坐标是视图（屏幕内的网页窗口）本身。会浮于默认模型上。<br><code>position:fixed</code><h5 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h5>1.absolute+relative<br>将前辈元素加上absolute属性<br>想移动的元素加上relative<br>此时以前辈元素形成一个坐标系，可以相对前辈元素改变位置。</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>闲看-数据集会有刻板印象吗？</title>
    <url>/2022/10/15/dataset-bias/</url>
    <content><![CDATA[<blockquote>
<p>本来是想看<em>Ruth Fong</em>这位作者的一些关于可解释模型的一些论文，但是无意中看到她作为共作的讨论数据集的性别刻板印象的论文，沉迷于此看了一天倒是忘记了最开始是要看别的来着…</p>
</blockquote>
<p>Meister, Nicole, et al. “Gender Artifacts in Visual Datasets.” arXiv preprint arXiv:2206.09191 (2022).</p>
<p>标题：<strong>Gender Artifacts in Visual Datasets</strong><br>论文地址：<a href="https://arxiv.org/abs/2206.09191">https://arxiv.org/abs/2206.09191</a><br>关键词：AI fairness, gender bias, dataset analysis</p>
<h2 id="0-摘要"><a href="#0-摘要" class="headerlink" title="0. 摘要"></a>0. 摘要</h2><p>我们已经知道性别偏差会出现在大型图像集中并且会影响下游任务模型。许多前序工作已经提出弱化这种偏差影响的手法比如尝试将性别情感相关的情报从图片里删除。为了理解这些手法的可行性和使用性，我们调查了大型图片集中究竟有哪些<em>性别伪影（gender artifacts）</em>。我们定义，性别伪影应该是一个</p>
<ol>
<li>可视的并且会被现代模型学习到的</li>
<li>能以人类思维解释的</li>
</ol>
<p>与性别相关的线索。通过我们的分析，我们发现在COCO和OpenImages数据集中，伪影可以说是无处不在，下到低阶信息（如色彩信息），上至高阶信息（如姿势和位置），都存在性别伪影。因此我们认为通过删除伪影的方法是不可行的。并且我们认为作为研究员和训练者的责任，他们更应该注意数据里的性别分布，并应该加强手法对这些分布偏差的鲁棒性。</p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>我们现在已知了很多深度学习模型的衍生物都有社会偏差。一种主要的假设是这种偏差源自于输入数据本身的问题。许多偏差都来自于特定群体的相关数据的缺乏，如天然的性别分布已经被论证不足以缓解模型的偏差。因此许多手法提出将具有性别色彩的元素进行遮挡的方法以避免输入数据的不均匀。</p>
<p>在本文中，我们不仅关注这些数据集的偏差，并且探索了这些性别信息究竟多大程度能被除掉。因此首先我们定义了<em>性别伪影</em>应该是可学习的和可解释的。并且为了探索这些伪影，我们生成和对比了许多不同版本的数据（如灰度化的图片，被遮挡背景的图片等），以探索它们的性别预测程度。</p>
<p>但是我们并不赞成任何预测性别的行为。并认为这里并没有任何理由足以支持这一行为。</p>
<p>根据上述工作，我们最终发现在COCO和OpenImage里性别伪影无处不在。如下图中仅仅是计算了图片中三原色的平均值，就能够看出两性之间的明显差异。通过平均值模型预测度为，COCO：58.0%, OpenImages：59.1%</p>
<p><img src="https://p.ipic.vip/bp87fo.png" alt="左：分割掩膜的相关统计量 右：图像的平均色彩度"></p>
<p>这些发现的暗示如下：</p>
<ol>
<li>性别伪影存在于图片的每个角落，因此过去的删除特定性别伪影的手法也许是无效的。我们更推荐研究者使用注重公平的模型，以及非聚合的验证矩阵。这能帮助发现潜在的群体偏差。</li>
<li>在我们的发现中，这些性格偏差的无处不在性导致最终的预测可能是毫无道理的。比如每当让模型预测性别时，我们需要积极地考虑预预测依据是什么；模型是真的学习到了有意义的理由，还是仅仅是因为图片更红一些。</li>
</ol>
<p>最后，我们也要考虑不是所有伪影都是错误的。有一些也许是真的能够帮助我们区别两个群体，它们是重要的特征；但有一些仅仅是讨厌的刻板印象。我们需要考虑哪些是要避免的。</p>
<h2 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h2><h2 id="3-实验"><a href="#3-实验" class="headerlink" title="3. 实验"></a>3. 实验</h2><h3 id="3-1-数据集"><a href="#3-1-数据集" class="headerlink" title="3.1 数据集"></a>3.1 数据集</h3><p>使用COCO和OpenImages的主要原因是它们是少见的能直接获得性别标签的注释。</p>
<h3 id="3-2-模型参数"><a href="#3-2-模型参数" class="headerlink" title="3.2 模型参数"></a>3.2 模型参数</h3><h3 id="3-3-道德考虑"><a href="#3-3-道德考虑" class="headerlink" title="3.3 道德考虑"></a>3.3 道德考虑</h3><hr>
<blockquote>
<p>以下开始是产生性别伪影的原因的实验和探讨</p>
</blockquote>
<h2 id="4-分辨率和颜色"><a href="#4-分辨率和颜色" class="headerlink" title="4. 分辨率和颜色"></a>4. 分辨率和颜色</h2><p>我们测试了测试集在112x112, 56x56, 28x28, 14x14, 7x7这几种分辨率情况下的预测情况。随着分辨率下降，准确度也逐步下降，但是颜色也逐渐变得单一。因此我们也考虑了当转化为灰度图片后随着分辨率下降预测度的情况。结果如下图所示。</p>
<p><img src="https://p.ipic.vip/6ovrla.png" alt="Color：彩色，Grayscale：灰度，LogReg：红绿蓝三原色的像素块个数的平均值"></p>
<p>在28x28的分辨率下的COCO数据集中，彩色图片预测率有61.9%而灰度图片仅有51.9%。这说明在图片的物体形状不再具有意义时，性别伪影很可能来自于色彩的影响。</p>
<p>并且即使将分辨率低到了7x7的程度，彩色图片的预测率依旧高于50%。</p>
<p>这很有可能数据集中的两性具有一定的色彩特征。男性更常是在绿色草坪上，而数据集中的女性更常拥有更亮色的皮肤。</p>
<h2 id="5-人和背景"><a href="#5-人和背景" class="headerlink" title="5. 人和背景"></a>5. 人和背景</h2><p>前序工作中已经证明人物的样貌一定包含了性别伪影。那么更朴素的问题是，是否图片背景，甚至是更高阶的人物信息（姿势和大小等）会包含人物伪影？</p>
<p>我们设置了一系列的遮挡图片来对比对预测度的影响，术语解释如下：</p>
<ol>
<li>Full：人物完全被显示出来</li>
<li>Full NoBg：人物完全被显示并且没有背景</li>
<li>MaskSegm：人物掩膜</li>
<li>MaskRect：矩形掩膜</li>
</ol>
<p>最终结果如下图</p>
<p><img src="https://p.ipic.vip/62qmuv.png" alt=""></p>
<p><strong>人物外貌是性别伪影。</strong>很明显，即使遮挡住背景时（Full Nobg），预测度也没有剧烈的下降。</p>
<p><strong>仅仅使用人物的形状和位置对性别进行预测也达到了50%以上。</strong>我们看到即使在MaskSegm NoBg的情况下，也达到了74.8%的准确率，说明人物形状本身都能揭露性别情报，比如着装或是头发的长短。接下来，我们删除了更多人物信息，只留下了关键点(keypoints)如下图。</p>
<p><img src="https://p.ipic.vip/e28dt9.png" alt=""></p>
<p>它们的表现依旧优于50%达到了64.8%的准确度。男性的动作有可能被模型认为更小和在运动状态；而女性更多的被模型认为倾向于更大和站立。</p>
<p><strong>这些不同性别表达中的大小和位置差异是可被学习的。</strong>即使我们把人物轮廓遮住（MaskRectNoBg），结果仍表现出了高于50%的精度。</p>
<p><strong>背景信息仍旧是极其重要的信息对于表达性别信息。</strong>因此任何仅仅只是通过遮挡人物外貌的方法，只不过是把性别伪影从人物转移到了背景上，实际上是无法真正消除所有性别伪影的。</p>
<p><strong>定性分析。</strong>为了进一步理解背景中的性别伪影，我们进行了一系列定性分析结果如下图。<br><img src="https://p.ipic.vip/adv6fw.png" alt="值为100意味着被预测为女性，0则为男性"></p>
<p>模型倾向于将城市和室内的背景与女性连接起来，而将室外和运动背景与男性结合。此外，通过第四行我们发现状态更“小”和静止时常被模型认为是女性，而“大”和动态被认为是男性。但是，我们也发现了如果人物外貌被包含在图片里时，运动的女性和静止的男性也是可以被正确区分的。</p>
<p><strong>性别伪影在数据集中具有普遍性。</strong>我们对两个数据集进行了交叉验证如下表，不管是哪种掩膜设定最终结果都高于50%。</p>
<p><img src="https://p.ipic.vip/wdpf1d.png" alt=""></p>
<h2 id="6-具有语义内容的物体"><a href="#6-具有语义内容的物体" class="headerlink" title="6. 具有语义内容的物体"></a>6. 具有语义内容的物体</h2><p>这一章节我们致力于更好的理解性别伪影，并区别背景中的两大要素：物体和场景。</p>
<p><strong>通过模型的关注度可视化性别伪影。</strong>我们使用CAMS可视化了不同物体在用于性别分类时的重要度，如下图</p>
<p><img src="https://p.ipic.vip/j47vr1.png" alt=""></p>
<p>当人物被预测为女性时，模型在关注室内的物体如床和烤箱；而被预测为男性时，模型关注于室外物体如滑板和摩托。</p>
<p><strong>和性别分类最有关的物体排序。</strong>在COCO中，比重最高的十个物体对应用于分类女性的，分别为吹风机，手提包，泰迪熊，雨伞和床；而比重最低的十个物体对应于分类男性，为滑板，领带，滑雪板，棒球手套和摩托车。</p>
<p>为了进一步理解这些物体的作用，我们逐步从图片中删除各个物体，并观察预测结果的准确率的变化。结果如下图。</p>
<p><img src="https://p.ipic.vip/w08stw.png" alt=""></p>
<p>我们可以看到，物体产生的影响无处不在；直到我们将物体删除到一个不剩，判定率才下降到了50%的基准。</p>
<h2 id="7-讨论"><a href="#7-讨论" class="headerlink" title="7. 讨论"></a>7. 讨论</h2><p>首先，我们应该面对这种数据集中的不均匀而不是妄图消灭它们（我们已经证明了这几乎不可能）。因此使用注重公平性的模型是更好的选择。</p>
<p>此外，在构建数据集时我们也要尽量避免这种产生的偏差。我们应提前考虑这种结构是否会影响到下游任务的结果。</p>
<p>最后，我们应该警惕模型的学习结果。也许一些模型的结果真的和人类的判断结果相符合，甚至和我们的认知对应。但实际上它可能只是在学习这个数据集中的可视化物体的关联性，而不是真正的“理解”。当我们对结果分析时，我们应该小心我们的分析是不是其实仅仅是人类自己“赋予”的。</p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>【项目实战】德英互译NLP模型</title>
    <url>/2022/07/31/de-en-translation/</url>
    <content><![CDATA[<h1 id="项目报告"><a href="#项目报告" class="headerlink" title="项目报告"></a>项目报告</h1><p><a href="/butterfly/nlp.pdf">pdflink<a><br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5vwr2ng3wj20yt0g70v4.jpg" alt=""></p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>围绕机器翻译，对NLP知识进行了总结复习和实战。首先总结了机器翻译模型的发展历史，并对相关技术进行复习。最后使用了几个前沿的预训练模型对德英数据集进行了微调，并使用不同的分词手法和评估函数进行了对比。</p>
<h1 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h1><ol>
<li>RNN：加入了上一个隐藏层的输入以记忆历史数据，最先被提出用来解决时间序列模型的结构。但是过长的文本会导致梯度消失。</li>
<li>LSTM/GRU：解决长文本问题，可提供对更久以前的数据的记忆。</li>
<li>Attention机制：1. 提供弹性表达（而不是只能将文本映射为固定长度的向量） 2. 可学习全局的关系 3. 并行计算</li>
<li>双循环网络：初期的RNN只能单向循环，即只能看到前面的内容，看不到后面。双循环添加了从后向前的方向，使输出不仅依靠前面的文本还可知晓后面的内容。</li>
<li>Transformer：结合上述结构的优势，生成了强大的Transformer。在Transformer基础上还诞生了BERT等强大的模型。</li>
</ol>
<h1 id="使用手法"><a href="#使用手法" class="headerlink" title="使用手法"></a>使用手法</h1><p>主要使用基于Transformer模型T5和Transformer-align，对机器翻译任务进行迁移学习。</p>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><ul>
<li>Dataset：Multi50k</li>
<li>Evaluation：Bleu</li>
</ul>
<p>下面两张图分别是在测试集的损失变化，和Bleu的变化量。可以看出Transfromer align在本次任务中表现最好。</p>
<p><img src="https://p.ipic.vip/d2dw7h.png" alt=""></p>
<p>我们还实现了词语之间的attention值的可视化，更明显的看出每个生成词语的参考来源。</p>
<p><img src="https://p.ipic.vip/xu6hy3.png" alt=""></p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Diffusion model 总结</title>
    <url>/2023/05/09/diffusion-model/</url>
    <content><![CDATA[<blockquote>
<p>从去年diffusion的崛起陆陆续续的看了很多文章和应用，也有在自己的研究上加入一些元素。但是浑浑噩噩下来其实对于dm的历史以及进化过程很是浅显， 笔记也非常零碎，借此文章对笔记进行一些整理</p>
</blockquote>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>T：定量。确定的时间步长。</p>
<p>t：变量。对应的时间步。</p>
<h2 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a>生成模型</h2><p>生成模型的根本其实就是：<strong>将训练数据和生成数据的分布尽可能接近</strong></p>
<p><em>如果将一个个的sample看做是一个个人类，那么控制的参数则有性别，年龄，身高，器官的大小……这些数据的分布情况都决定了AI创造的的新种族是否与人类相似。如果这个种族的平均身高只有120，那必然怎么看都只能算侏儒群体。</em></p>
<p>将两个数据的分布靠近的方法可以分为下面两类：</p>
<ol>
<li>直接计算：<ul>
<li>严密计算：Flow-based</li>
<li>使用易于计算的上限值计算：VAE,diffusion</li>
</ul>
</li>
<li>间接达成<ul>
<li>GAN</li>
</ul>
</li>
</ol>
<p>在两种方法中，以GAN为首的间接达成的方法曾经一直是主流。其通过增加分辨器的方式进行对抗学习，”逼迫“生成器必须提取非常抽象的特征以生成无法被识别出来真假的sample。但是它的缺点是<strong>不够精细，生成样本的质量参差不齐</strong>。最近以Diffusion为主的直接计算法又再次登上舞台，但是只要尝试后就知道其在<strong>某些领域的生成能力和总体的消耗时间</strong>其实仍不如GAN，这也是目前对diffusion优化的方向之一（优化模型，提高泛化能力[Diffusion models beat GANs on image synthesis]）</p>
<h2 id="Diffusion-Model"><a href="#Diffusion-Model" class="headerlink" title="Diffusion Model"></a>Diffusion Model</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>首先DM在做的事情其实就是<strong><strong><strong><em>**</em></strong></strong></strong>基于扩散模型的学习过程。<strong><strong><strong><em>**</em></strong></strong></strong>扩散模型是指马尔科夫过程，也就是将一段一段的迁移过程直接用一个式子概括的定理。DM整个过程都基于这个定理。</p>
<p>DM的学习和生成过程可以用下面这张看烂的图概括</p>
<p><img src="https://p.ipic.vip/uxpgor.png" alt=""></p>
<p>学习过程(Forward process)：0到T的过程。从原图片变成遵循高斯分布的噪声。记为q。</p>
<p>训练过程(Reverse process)：T到0的过程。从噪声变成图片。记为p。</p>
<p>X0始终代表原始图片，之后的Xt都是从原图片提取出来的特征也好变量也好的东西。</p>
<h3 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h3><p>单个一小步的过程的迁移概率如下：</p>
<p>${q(X_t|X_{t-1})=\mathcal N(X_t;\sqrt{1-\beta_t}X_{t-1},\beta_tI)}$</p>
<p>根据马尔科夫定理，将所有迁移过程汇总为如下的一个式子</p>
<p>${q_\theta}(X_{1:T}|X_0) = \prod^T_{t=1}q(X_t|X_{t-1})$ </p>
<p>可以看到，里面其实只有一个参数beta。这个beta也是定好的，会随着定义好的schedular线性或者对数改变，在代码中一般定义为beta_schedular。因此在<strong>整个学习过程中没有需要学习的参数。</strong></p>
<blockquote>
<p>一些思虑：<br>Xt究竟用什么表示？我们只定义了迁移过程的概率式，但是Xt究竟用什么表示呢？<br>应该是在学习过程就定死的。学习过程相当于外部添加噪声的过程，这个噪声通常是由随机函数产生，因此这个是已知量。</p>
</blockquote>
<h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p>首先我们假设学习过程中最终生成的噪声图片遵循平均值0分布为1的正态分布（可能通过什么转换变成的）</p>
<p>${p(X_T)=\mathcal N(0,I)}$</p>
<p>每一步的去噪过程可被表述为与加噪过程相同的形式。不同的是，这里的平均值和分布不再是之和beta相关的定值，而是需要DNN进行学习的未知参数。</p>
<p>${p_\theta(X_{t-1}|X_t)=\mathcal N(X_{t-1};\mu_\theta(x_t,t), \Sigma_\theta(x_t,t))}$</p>
<p>z最终整个过程被表现为</p>
<p>${p_\theta(X_0:T)=p_{\theta}(X_t)\prod^T_{t=1}p_\theta(X_{t-1}|X_t)}$</p>
<blockquote>
<p>其实我还是没有太搞懂。概率的过程和最终的生成同样图片的关联在哪里。</p>
</blockquote>
<h2 id="Diffusion-Models-Beat-GANs-on-Image-Synthesis-中的解释"><a href="#Diffusion-Models-Beat-GANs-on-Image-Synthesis-中的解释" class="headerlink" title="Diffusion Models Beat GANs on Image Synthesis 中的解释"></a>Diffusion Models Beat GANs on Image Synthesis 中的解释</h2><p><img src="https://p.ipic.vip/cx7b67.png" alt=""></p>
<p>……在高层面来说，扩散模型其实就是通过一个反转的加噪过程，来对分布进行采样。这个过程从Xt持续到X0。不同的时间步t对应不同的噪声等级。对于每个Xt可以看做是X0和一个与t成比例的噪声e混合而成的数据。其中在本文中，我们假设e是从高斯分布中提取出来的。</p>
<blockquote>
<p><em>但是这个去噪的过程是很复杂的。虽然DM很牛掰但是也不可能一下子就学会整个过程。就像人画东西也需要一个部位一个部位的画，而DM需要一个层次一个层次的画。所以DM的整个创作过程是由无数个简单的创作过程组成的。</em></p>
</blockquote>
<p>扩散模型的目的是学会如何从Xt中创作一个噪声能稍微少一点的Xt-1。[1] 用噪声预测函数 ${noise’=\epsilon_\theta(x_t, t)}$对模型参数化（即下图的Noise Predictor）。</p>
<blockquote>
<p>如果用吴恩达的图片也许会更清晰：</p>
<p><img src="https://p.ipic.vip/8kv9ja.png" alt=""></p>
</blockquote>
<p>在训练过程中，</p>
<ol>
<li>我们会对原始图片进行逐渐加噪。加噪是利用已知的原始图片X0，现在的时间步t’，和随机噪声 ${\epsilon}$，利用这些来生成Xt。生成的原理是根据下面的式子：</li>
</ol>
<p>${q(X_t|X_{t-1})=\mathcal N(X_t;\sqrt{1-\beta_t}X_{t-1},\beta_tI)}$</p>
<p>${q_\theta}(X_{1:T}|X_0) = \prod^T_{t=1}q(X_t|X_{t-1})$ </p>
<ol>
<li>s根据生成的Xt我们利用噪声预测函数对噪声进行反推。显而易见，损失函数就是我们真正的已知的噪声 ${\epsilon}$和预测出的噪声 ${noise’=\epsilon_\theta(x_t, t)}$的差值</li>
</ol>
<p>${||\epsilon_\theta(x_t, t)-\epsilon||^2}$</p>
<p>训练过程解决了，那我们究竟如何利用噪声预测器对噪声图片采样以获得原始图片呢？也就是上面吴恩达的图片的减号的部分，到底是如何实现的？</p>
<p>实际上在[1]中，作者假设了从Xt到Xt-1的过程也是遵从高斯分布的，即</p>
<p>${p_\theta(X_{t-1}|X_t)=\mathcal N(X_{t-1};\mu_\theta(x_t,t), \Sigma_\theta(x_t,t))}$</p>
<p>其中的平均值mu实际上就可以从噪声预测器的结果获得；而方差是由一个定数决定。因此DM整个的学习过程就是<strong>训练噪声预测函数</strong>！</p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>原理和代码对照学习：</p>
<p><a href="https://nn.labml.ai/diffusion/ddpm/index.html">https://nn.labml.ai/diffusion/ddpm/index.html</a></p>
<p>[1] Denoising diffusion probabilistic models.</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-2（动态算法）</title>
    <url>/2022/11/06/dynamic-programming/</url>
    <content><![CDATA[<blockquote>
<p>求解决策过程(decision process)最优化的数学方法。</p>
</blockquote>
<hr>
<h2 id="剑指10-1-斐波那契数列"><a href="#剑指10-1-斐波那契数列" class="headerlink" title="剑指10-1. 斐波那契数列"></a>剑指10-1. 斐波那契数列</h2><p><strong>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：<br>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</strong></p>
<ul>
<li>避免重复计算因此使用动态算法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
<h2 id="剑指10-2-青蛙跳台阶"><a href="#剑指10-2-青蛙跳台阶" class="headerlink" title="剑指10-2. 青蛙跳台阶"></a>剑指10-2. 青蛙跳台阶</h2><p><strong>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</strong><br><strong>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</strong></p>
<ul>
<li>本质还是斐波那契数列</li>
<li>注意当n=0时，因为只能不跳所以等于1（这个题的毛病不要太钻牛角尖）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numWays</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment">## 最后一步一定是一阶或是两节</span></span><br><span class="line">        <span class="comment">## 剩一节时的方法有f(n-1)种，剩两节有f(n-2)种，则f(n)=f(n-1)+f(n-2)</span></span><br><span class="line">        <span class="comment">## f(0) = 1, f(1) = 1, f(2) = 2</span></span><br><span class="line"></span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n) :</span><br><span class="line">            a, b = b, a+b</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>
<h2 id="剑指16-从尾到头打印链表"><a href="#剑指16-从尾到头打印链表" class="headerlink" title="剑指16. 从尾到头打印链表"></a>剑指16. 从尾到头打印链表</h2><p><strong>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</strong></p>
<p>解题思路：</p>
<p>用list顺序存储单向链表，使用切片直接倒序输出。</p>
<p>Tip：</p>
<ul>
<li>列表切片规则<code>List[start:stop:step]</code>，不加则是默认全部区间</li>
<li><code>List[::-1]</code>则代表倒置列表</li>
</ul>
<p>复杂度</p>
<ul>
<li>时间O(n)， 空间O(n)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePrint</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            result.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="剑指24-翻转链表（中转-递归）"><a href="#剑指24-翻转链表（中转-递归）" class="headerlink" title="剑指24. 翻转链表（中转+递归）"></a>剑指24. 翻转链表（中转+递归）</h2><p><strong>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</strong></p>
<p>解题思路：<br>需要解决的问题其实有两个：1. 如何改变node之间的指向 2. 如何保存头部节点</p>
<ol>
<li>使用<strong>中转点</strong>对上一个node保存，遍历链表同时改变指向，最后一个到达的就是新链表的头部节点</li>
<li>递归。只有到达最后一个节点后才开始进行翻转。这里通过返回值不停传递末节点，即新链表的头结点。<ul>
<li>传递参数：当前节点和下一节点</li>
<li>停止条件：当前节点为空</li>
<li>返回值：上一节点</li>
<li>执行动作：将下一节点指向当前节点</li>
</ul>
</li>
</ol>
<p>复杂度</p>
<ul>
<li>时间：O(n)，空间：O(2)</li>
</ul>
<h3 id="中转站法"><a href="#中转站法" class="headerlink" title="中转站法"></a>中转站法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        prevNode = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            head.<span class="built_in">next</span> = prevNode</span><br><span class="line">            prevNode = head</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prevNode</span><br></pre></td></tr></table></figure>
<ul>
<li>时间：O(n)，</li>
<li>空间：O(n):递归深度达到n，需要n的空间</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recur</span>(<span class="params">cur: ListNode, prev: ListNode</span>) -&gt; ListNode:</span><br><span class="line"></span><br><span class="line">            <span class="comment">## 迭代中止：到达最后一个Node的时候next会变成None，这时返回最后一个Node</span></span><br><span class="line">            <span class="comment">## 最后一个Node会变成新链表的head，使用变量进行保存</span></span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                head = recur(cur.<span class="built_in">next</span>, cur)</span><br><span class="line">                cur.<span class="built_in">next</span> = prev</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(head, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<h2 id="剑指18-删除链表的节点"><a href="#剑指18-删除链表的节点" class="headerlink" title="剑指18. 删除链表的节点"></a>剑指18. 删除链表的节点</h2><p><strong>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</strong></p>
<p><strong>返回删除后的链表的头节点。</strong></p>
<p>时间O(n)， 空间O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, head: ListNode, val: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head : <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> head.val == val : <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        result = head </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span> :</span><br><span class="line">            <span class="keyword">if</span> head.<span class="built_in">next</span>.val == val :</span><br><span class="line">                head.<span class="built_in">next</span> = head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="剑指22-链表中倒数第k个字节（快慢指针）"><a href="#剑指22-链表中倒数第k个字节（快慢指针）" class="headerlink" title="剑指22. 链表中倒数第k个字节（快慢指针）"></a>剑指22. 链表中倒数第k个字节（快慢指针）</h2><p><strong>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</strong></p>
<p><strong>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</strong></p>
<blockquote>
<p>遍历法很容易想到就不在这里赘述了</p>
</blockquote>
<ul>
<li>时间O(n) 空间O(1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKthFromEnd</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        slow, fast = head, head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>) :</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> fast.<span class="built_in">next</span> :</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<h2 id="剑指25-合并两个排序的链表"><a href="#剑指25-合并两个排序的链表" class="headerlink" title="剑指25. 合并两个排序的链表"></a>剑指25. 合并两个排序的链表</h2><p><strong>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</strong></p>
<ul>
<li>善用伪头结点可以减少很多步骤，如判断哪个才是头结点造成的代码行数增加</li>
<li>因为是链表结构而非数组，因此不用考虑最后剩下的需要用while再一个个塞进去</li>
<li>时间O(n)， 空间O(1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:  </span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2 :</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val :</span><br><span class="line">                cur.<span class="built_in">next</span>, l1 = l1, l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                cur.<span class="built_in">next</span>, l2 = l2, l2.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> l1 :</span><br><span class="line">            cur.<span class="built_in">next</span> = l1</span><br><span class="line">        <span class="keyword">if</span> l2 :</span><br><span class="line">            cur.<span class="built_in">next</span> = l2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Edge Detection</title>
    <url>/2022/05/09/edge%20detection/</url>
    <content><![CDATA[<h1 id="1-Feature-detection"><a href="#1-Feature-detection" class="headerlink" title="1 Feature detection"></a>1 Feature detection</h1><blockquote>
<ul>
<li>Containing vast information</li>
</ul>
</blockquote>
<p>SO it’s important to <mark class="hl-label red">determine</mark> </p>
<ol>
<li><p>WHERE</p>
<ul>
<li><strong>concentrate on a part</strong> and <strong>ignore others</strong></li>
<li>e.g. Object recognition: Ignore background</li>
</ul>
</li>
<li><p>WHAT</p>
<ul>
<li>Feature can be located<ul>
<li>edge</li>
<li>feature points</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="2-Edge-detection"><a href="#2-Edge-detection" class="headerlink" title="2 Edge detection"></a>2 Edge detection</h1><h2 id="2-1-Feature"><a href="#2-1-Feature" class="headerlink" title="2.1 Feature"></a>2.1 Feature</h2><ol>
<li>Brightness (value) changes <strong>rapidly</strong></li>
<li>Differentiation (近傍ピクセルとの微分処理 ) </li>
<li>Important feature for object recognition </li>
<li>Weak to noise(Because it is differentiation)</li>
</ol>
<h2 id="2-2-Kinds"><a href="#2-2-Kinds" class="headerlink" title="2.2 Kinds"></a>2.2 Kinds</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h22h9p2btmj211z0n2abr.jpg" alt=""></p>
<h2 id="2-3-Differentiation"><a href="#2-3-Differentiation" class="headerlink" title="2.3 Differentiation"></a>2.3 Differentiation</h2><ul>
<li><p>Grandient</p>
<script type="math/tex; mode=display">\nabla I=(\frac{\partial I}{\partial x}, \frac{\partial I}{\partial y})</script><ul>
<li>Represents the<strong> direction and the speed</strong> of the <strong>change in brightness </strong></li>
</ul>
</li>
<li><p>Laplacian</p>
<script type="math/tex; mode=display">\nabla^2 I=(\frac{\partial^2 I}{\partial x^2}, \frac{\partial^2 I}{\partial y^2})</script></li>
</ul>
<div class="note info modern"><p>边缘就是明暗剧烈变化的地方，所以我们可以通过一次微分的极值或二次微分的变曲点确定edge</p>
</div>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h231usx1ugj20sl0gd764.jpg" alt=""></p>
<h1 id="3-edge-operator"><a href="#3-edge-operator" class="headerlink" title="3 edge operator"></a>3 edge operator</h1><blockquote>
<p>为了计算微分，我们通过edge operator——即一种filter来实现</p>
</blockquote>
<h2 id="3-1-一次微分"><a href="#3-1-一次微分" class="headerlink" title="3.1 一次微分"></a>3.1 一次微分</h2><p>对于一个形同$[[I_{i,j+1}, I_{i+1,j+1}],[I_{i,j}, I_{i+1,j}]]$的2*2 window内的像素，我们可以将微分转换为</p>
<script type="math/tex; mode=display">\frac{\partial I}{\partial x} \approx \frac{1}{2\varepsilon}((I_{i+1,j+1}-I_{i,j+1})+(I_{i+1,j}-I_{i,j}))</script><script type="math/tex; mode=display">\frac{\partial I}{\partial y} \approx \frac{1}{2\varepsilon}((I_{i,j+1}-I_{i,j})+(I_{i+1,j+1}-I_{i+1,j}))</script><p>表现为filter即为</p>
<p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h231ypgyluj20vp0audgc.jpg" alt=""></p>
<p>分别求出两个方向的edge后合并才能生成总的edge图</p>
<ul>
<li>Location more precise</li>
<li>Weak to noise </li>
<li>Low detection power<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h231uu19ctj20ut0gu40l.jpg" alt=""><script type="math/tex; mode=display">对噪声的优化很弱的后果...处处都是边缘！</script></li>
</ul>
<h2 id="3-2-二次微分"><a href="#3-2-二次微分" class="headerlink" title="3.2 二次微分"></a>3.2 二次微分</h2><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h231utawi2j20cg0aeq3b.jpg" alt=""></p>
<script type="math/tex; mode=display">\frac{\partial^2 I}{\partial x^2} \approx \frac{1}{\varepsilon^2}(I_{i-1,j}-2I_{i,j}+I_{i+1,j})</script><script type="math/tex; mode=display">\frac{\partial^2 I}{\partial y^2} \approx \frac{1}{\varepsilon^2}(I_{i,j-1}-2I_{i,j}+I_{i,j+1})</script><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h231utl5ycj210q08xq3v.jpg" alt=""></p>
<h2 id="3-3-算法"><a href="#3-3-算法" class="headerlink" title="3.3 算法"></a>3.3 算法</h2><ul>
<li>Roberts</li>
<li>Prewitt<ul>
<li>先ほどのカーネルではノイズの影響が非常に強く出てしまうので、平滑化処理を加えた形</li>
</ul>
</li>
<li><p>Sobel</p>
<ul>
<li>Location imprecise </li>
<li>Robust to noise </li>
<li>High detection power </li>
</ul>
</li>
<li><p>LoG<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h231uui5vej20xn0pbjuq.jpg" alt=""></p>
<ul>
<li>用于平滑化</li>
<li>近似于DOG（倒不如说有时候用DOG会更方便所以可以近似）</li>
</ul>
</li>
<li>Canny<ul>
<li>通过将一系列的检出算法合并的强力检出工具<ol>
<li>Blur image I with 2D Gaussian</li>
<li>Find the edge‐normal direction at each pixel:</li>
<li>Calculate the strength of the edge</li>
<li>Find the maximal strength in the edge‐normal direction as the zero‐crossing in that direction (this step is called non‐maximum suppression)</li>
</ol>
</li>
<li>改变参数$\sigma$可以提取各种各样不同的特征 </li>
</ul>
</li>
</ul>
<h1 id="4-Corner-detection"><a href="#4-Corner-detection" class="headerlink" title="4. Corner detection"></a>4. Corner detection</h1><blockquote>
<p>除了通过微分求出练成线的轮廓线，我们还可以通过求物体“角点”确认物体的位置</p>
</blockquote>
<h2 id="4-1-Susan"><a href="#4-1-Susan" class="headerlink" title="4.1 Susan"></a>4.1 Susan</h2><ol>
<li>window作为一个圆形对图片遍历，圈内与圆心相同亮度的部分称为USAN</li>
<li>若USAN的面积小于某个阈值即认为这个点是角点（就是在圆内占比极低）<blockquote>
<p>想象一个比例为1:3的饼状统计图…那1/4是不是就是个正方形的角？</p>
</blockquote>
</li>
<li>USAN面积排行<ol>
<li>圆内全部为相同亮度（即在一个物体内部时）面积最大</li>
<li>圆内只有一半左右为相同亮度（即边缘）面积次大</li>
<li>圆内只有小部分为相同亮度时（即角）面积最小<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h232kivengj20iw0ck75h.jpg" alt=""></li>
</ol>
</li>
</ol>
<h2 id="4-2-harris"><a href="#4-2-harris" class="headerlink" title="4.2 harris"></a>4.2 harris</h2><p>Detect a point where the sum of square changes<br>of the image is largest when shifted slightly</p>
<ul>
<li>Points easily distinguishable from nearby points</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>【花书】从函数梯度到深度学习的优化算法</title>
    <url>/2023/01/03/gradient-optimization/</url>
    <content><![CDATA[<p>参考深度学习花书</p>
<p>第四章 数值计算【梯度下降，约束优化】</p>
<p>第八章 深度学习中的优化【优化问题，优化算法】</p>
<blockquote>
<p>主要整理了1. 梯度的定义和性质，以及如何运用到寻找函数的极值点 2. 寻找极值点中，如果我们需要添加额外条件，需要使用到约束优化 3. 深度网络的优化学习中的挑战和应用 4. 基于梯度，当今流行的深度网络优化算法</p>
</blockquote>
<h2 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h2><h3 id="梯度定义"><a href="#梯度定义" class="headerlink" title="梯度定义"></a>梯度定义</h3><p>梯度不仅可以表现为一个函数 $y=f(x)$，他的定义式还可以解读为“<strong>表明如何缩放输入的小变化才能在输出获得相应的变化</strong>”：</p>
<script type="math/tex; mode=display">f(x+\epsilon) \approx f(x)+\epsilon f'(x)</script><p>因此梯度对我们的优化问题非常有用：她告诉我们<strong>如何通过更改x来略微的调整y</strong>  → 梯度下降法</p>
<h3 id="一次梯度"><a href="#一次梯度" class="headerlink" title="一次梯度"></a>一次梯度</h3><p>当我们有<strong>多个输入</strong>(一个函数多个变量)时，梯度是元素为 $\frac{\partial}{\partial x_i}f(x)$ 的向量</p>
<p>当我们有<strong>多个输入和多个输出</strong> (多个函数多个变量)时</p>
<ul>
<li><p>Jacobian 矩阵：相比于只有多个输入的情况，我们将<strong>同一个输出函数对于不同的变量</strong>的偏导写到<strong>行</strong>上，不同输出函数写到<strong>列</strong>上；因此构成了<strong>矩阵</strong></p>
<script type="math/tex; mode=display">J=\frac{\partial}{\partial x_j} f(x)</script></li>
</ul>
<h3 id="二次梯度"><a href="#二次梯度" class="headerlink" title="二次梯度"></a>二次梯度</h3><ul>
<li>Hessian 矩阵<script type="math/tex; mode=display">H(f(x))_{i,j}=\frac{\partial ^2}{\partial x_i\partial 
x_j} f(x)</script></li>
</ul>
<h2 id="梯度性质"><a href="#梯度性质" class="headerlink" title="梯度性质"></a>梯度性质</h2><h3 id="一次梯度-1"><a href="#一次梯度-1" class="headerlink" title="一次梯度"></a>一次梯度</h3><p>明显的是，<strong>大于0函数递增，小于0函数递减</strong>。但我们无法确认当等于0时（临界点）函数的情况，因为他可能有以下任意情形：</p>
<ul>
<li>局部极大点</li>
<li>局部极小点</li>
<li>鞍点</li>
</ul>
<h3 id="二次梯度-1"><a href="#二次梯度-1" class="headerlink" title="二次梯度"></a>二次梯度</h3><p>与曲率相关：<strong>小于0时为凸，大于0为凹</strong></p>
<p><img src="https://p.ipic.vip/t3i4kc.png" alt=""></p>
<h3 id="一次梯度与二次梯度的结合"><a href="#一次梯度与二次梯度的结合" class="headerlink" title="一次梯度与二次梯度的结合"></a>一次梯度与二次梯度的结合</h3><p>方法一：</p>
<p>$\nabla f(x) = 0, \nabla^2 f(x) &gt; 0$ ：极小值</p>
<p>$\nabla f(x) = 0, \nabla^2 f(x) &lt; 0$ ：极大值</p>
<p>方法二：</p>
<p>实际上，当一阶前提符合时（为0），我们并不需要计算出所有输入的二阶；而是利用hessian矩阵的实对称性即<strong>特征值分解</strong>，判断大于0还是小于0。具体方法是计算<strong>hessian的正定性（所有特征值均为正）</strong>，则H大于0。其他情况</p>
<ul>
<li>均为负，H小于0</li>
<li>有正有负，鞍点</li>
</ul>
<h2 id="利用梯度的优化算法"><a href="#利用梯度的优化算法" class="headerlink" title="利用梯度的优化算法"></a>利用梯度的优化算法</h2><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>梯度下降是只利用一次梯度的一种最简单的优化算法。</p>
<p>由梯度性质可知 $-sign(f’(x))$ <strong>永远指向y减小的方向</strong>（1或-1），因此我们据此对x进行更新（如果是多维输入则是偏导且对每个x元素更新）：</p>
<script type="math/tex; mode=display">x \leftarrow x-\epsilon f'(x)</script><blockquote>
<p>$\epsilon$ 是学习率，也就是要基于减少方向缩放多少作为我们的步长</p>
</blockquote>
<h3 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h3><p>牛顿法是结合了一次梯度和二次梯度的优化算法。</p>
<script type="math/tex; mode=display">x^* = x^{(0)}-H(f)(x^{(0)})^{-1}\nabla_xf(x^{(0)})</script><p>当f为正定二次函数时，牛顿法可使它直接跳至全局最小点</p>
<h2 id="约束优化"><a href="#约束优化" class="headerlink" title="约束优化"></a>约束优化</h2><p>大多数情况，对于x所有可能值最小化函数并不是我们所期望的。我们往往会<strong>“有条件的”进行优化。</strong>数学方式来说，也就是希望在x的某些集合S中找f(x)的最大值或者最小值。这称为约束优化。集合S内的点称为可行点。</p>
<h3 id="KKT方法"><a href="#KKT方法" class="headerlink" title="KKT方法"></a>KKT方法</h3><p>集合S的描述：</p>
<p>我们通过<strong>等式和不等式</strong>的形式描述S。我们使用m个等式约束（ $g^{(i)}$）和n个不等式约束（ $h^{(j)}$）,则：</p>
<script type="math/tex; mode=display">S = \{x|\forall i, g^{(i)}=0 \space and \space \forall j, h^{(j)}\leq 0 \}</script><p>最小化问题：</p>
<script type="math/tex; mode=display">L(x, \lambda, \alpha) = f(x) + \sum_i\lambda_ig^{(i)}(x)+ \sum_j\alpha_ih^{(j)}(x)</script><script type="math/tex; mode=display">min_{x} \space max_\lambda \space max_\alpha L(x,\lambda, \alpha)</script><h2 id="实例：线性最小二乘"><a href="#实例：线性最小二乘" class="headerlink" title="实例：线性最小二乘"></a>实例：线性最小二乘</h2><p>无约束的优化目标：</p>
<script type="math/tex; mode=display">f(x)=\frac{1}{2}||Ax-b||^2_2</script><p>梯度下降法：</p>
<ol>
<li><p>计算梯度：</p>
<p> $\nabla_xf(x)=A^T(Ax-b)$</p>
</li>
<li><p>更新x</p>
<p>$x \leftarrow x-\epsilon A^T(Ax-b)$</p>
</li>
</ol>
<p> 有约束的优化目标（约束：范数小于1）</p>
<script type="math/tex; mode=display">L(x,\lambda)=f(x) + \lambda(x^Tx-1)</script><ol>
<li><p>计算梯度</p>
<p>$\nabla_xL=A^T(Ax-b) + 2\lambda x$</p>
<p>$\nabla_\lambda L=x^Tx-1$ </p>
</li>
<li><p>联合求解</p>
</li>
</ol>
<h2 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h2><p>深度网络的优化方法：寻扎神经网络上的一组参数 $\theta$，它能显著的降低代价函数 $J(\theta)$，该代价函数通常包括整个训练集上的<strong>性能评估和额外的正则化项</strong></p>
<p>对于代价函数，我们实际上是希望能够对数据的<strong>原始分布</strong>进行最优化，即：</p>
<script type="math/tex; mode=display">J^*(\theta)=E_{(x,y)\sim p_{data}}L(f(x;\theta), y)</script><p> 但实际上我们不能获得所有的数据，即不能得到真实的原始分布。因此我们另辟蹊径，假定训练集的采样代表了原始数据的分布，称为“经验”</p>
<script type="math/tex; mode=display">J^(\theta)=E_{(x,y)\sim \hat{p}_{data}}L(f(x;\theta), y)=\frac{1}{m}\sum^{m}_{i=1}L(f(x^{(i)};\theta), y^{(i)})</script><p>基于最小化这种平均训练误差的训练过程称为<strong>经验风险最小化</strong>。但其难点是如果使用高容量的模型会简单地记住训练集，导致过拟合。</p>
<h2 id="采样方法"><a href="#采样方法" class="headerlink" title="采样方法"></a>采样方法</h2><ul>
<li>使用<strong>整个训练集</strong>进行优化的算法称为批量算法</li>
<li>每次只是使用<strong>一个样本</strong>的称为在线算法</li>
<li><p>只使用<strong>一部分样本</strong>的称为小批量方法，或随机方法</p>
<blockquote>
<p><strong>如何确定小批量的大小</strong></p>
<ol>
<li>随着批量的增大，预测的梯度精确性理所当然的会上升，但其回报是小于线性的</li>
<li>当批量小于某个值时将无法使用多核架构，计算时间也不会下降</li>
<li>硬件设施的计算能力</li>
<li>使用GPU时，2的幂数的批量大小会获得更小的运算时间，一般使用32~256</li>
<li>批量越小，噪声越大，则带来越大的正则化效果（泛化能力）</li>
<li>由于梯度的高方差，我们需要设置更小的学习率来保持稳定性。但是越小的学习率也会带来更久的运行时间。</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="神经网络优化的挑战"><a href="#神经网络优化的挑战" class="headerlink" title="神经网络优化的挑战"></a>神经网络优化的挑战</h2><ul>
<li><p>病态</p>
<p>  最具代表性的是二阶导Hessian矩阵的病态。效果是尽管梯度很强，学习会变得非常缓慢</p>
</li>
<li><p>局部极小值</p>
</li>
<li><p>鞍点</p>
<p>  多类函数有此性质：低维空间中大多数为局部极小值；但在<strong>高维空间中，鞍点更为常见</strong>。这使我们更难找到极值点。尤其对于牛顿法而言，它旨在找到最近的下坡，而并不是真的跳到极值点；因此除非最近的梯度为0的点是极值点，否则牛顿点会更容易跳到鞍点处。这也说明了为什么在高维空间中，二阶方法并不能取代原始的梯度下降法。</p>
</li>
<li><p>梯度爆炸</p>
<p>  多层神经网络中通常存在像悬崖一样的斜率较大的区域。由于梯度的迅速增大，被更新的x值会被<strong>弹射到非常远的位置</strong>，使得我们错过了可能存在的极值点。</p>
</li>
</ul>
<h2 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h2><h3 id="参数初始化策略"><a href="#参数初始化策略" class="headerlink" title="参数初始化策略"></a>参数初始化策略</h3><p>标准初始化：从下列分布中采样权重</p>
<script type="math/tex; mode=display">W_{i,j} \sim U(-\sqrt{\frac{6}{m+n}}, \sqrt{\frac{6}{m+n}})</script><h3 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h3><ul>
<li><p>SGD：随机梯度下降</p>
<p>  <img src="https://p.ipic.vip/mwigjl.png" alt=""></p>
<p>  在实践中，学习率 $\epsilon$需要<strong>随着回合数进行减低</strong>。在小批量算法中，采样带来的噪声并不会在达到极值点处消失，而是使代价函数趋于平缓。为了接近极值点，我们必须减少学习率避免产生震荡。</p>
<p>  缺点：学习过程很慢</p>
</li>
</ul>
<ul>
<li><p>使用动量的随机梯度下降</p>
<p>  加入了<strong>历史梯度</strong>对现在的影响。</p>
<p>  <img src="https://p.ipic.vip/j0p32p.png" alt=""></p>
<p>  $\alpha$越大，历史梯度对现在的影响越大。步长不再仅仅取决于当前的梯度，更取决于梯度的排列和大小：当许多连续的梯度指向相同的方向时，步长最大。</p>
</li>
</ul>
<h3 id="自适应学习率算法"><a href="#自适应学习率算法" class="headerlink" title="自适应学习率算法"></a>自适应学习率算法</h3><ul>
<li><p>AdaGrad</p>
<p>  利用历史梯度的平方根的反比决定每个参数的学习率。在参数空间更为平缓的倾斜方向会取得更大的进步。</p>
<p>  <img src="https://p.ipic.vip/n56vfr.png" alt=""></p>
<p>  优点：<strong>加快收敛速度</strong></p>
<p>  缺点：从训练开始时就积累平方梯度的话会导致学习率过早和过量的减小</p>
</li>
<li><p>RMSProp</p>
<p>  使用指数衰减平均以<strong>丢弃</strong>遥远过去的历史梯度<br>  <img src="https://p.ipic.vip/9s6cd3.png" alt=""></p>
</li>
<li><p>Adam</p>
<p>  加入了<strong>偏置修正</strong>，修正一阶矩估计和二阶矩估计</p>
<p>  <img src="https://p.ipic.vip/27g5ki.png" alt=""></p>
</li>
</ul>
<h3 id="常见算法总结"><a href="#常见算法总结" class="headerlink" title="常见算法总结"></a>常见算法总结</h3><ul>
<li>SGD为随机梯度下降,每一次迭代计算数据集的mini-batch的梯度,然后对参数进行更新</li>
<li>Momentum前几次的梯度也会参与到当前的计算中</li>
<li>Adagard在训练的过程中可以自动变更学习的速率,设置一个全局的学习率,而实际的学习率与以往的参数模和的开方成反比。</li>
<li>Adam利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率,在经过偏置的校正后,每一次迭代后的学习率都有个确定的范围,使得参数较为平稳。</li>
</ul>
<h3 id="一些经验谈"><a href="#一些经验谈" class="headerlink" title="一些经验谈"></a>一些经验谈</h3><p><strong>为什么我们依旧倾向于使用SGD?</strong> </p>
<p>尽管自适应梯度算法的收敛速度更快，但其<strong>泛化性能却比SGD算法差</strong>。具体来说，自适应梯度算法在训练阶段的进展很快，但在测试数据上的表现很快就会停滞不前。但是SGD通常对模型性能的改善很慢，但可以获得更高的测试性能。对于这种泛化差距的一种经验解释是，<strong>自适应梯度算法倾向于收敛到尖锐的极小值</strong>，其局部地区的曲率较大，所以泛化性能较差，而SGD则倾向于寻找平坦的极小值，因此泛化较好。[1] </p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]为什么Adam 不是默认的优化算法?,  <a href="https://zhuanlan.zhihu.com/p/557605698">https://zhuanlan.zhihu.com/p/557605698</a></p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>DL optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML总结</title>
    <url>/2020/03/10/html-memo/</url>
    <content><![CDATA[<blockquote>
<p><strong><em>“标签存在的意义不仅是他们呈现出来的样式，而是让浏览器更好的阅读”</em></strong></p>
</blockquote>
<h2 id="共通标签"><a href="#共通标签" class="headerlink" title="共通标签"></a>共通标签</h2><h3 id="HTML骨架"><a href="#HTML骨架" class="headerlink" title="HTML骨架"></a>HTML骨架</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;...&lt;/head&gt;</span><br><span class="line">    &lt;body&gt;...&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>\&lt;html\&gt;\&lt;/html\&gt;</code>称为根标签，所有的网页标签都在<code>\&lt;html\&gt;\&lt;/html\&gt;</code>中。</li>
<li><code>\&lt;head\&gt;</code>标签用于定义文档的头部，它是所有头部元素的容器。头部元素有<code>\&lt;title\&gt;、\&lt;script\&gt;、\&lt;style\&gt;、\&lt;link\&gt;、 \&lt;meta\&gt;</code>等标签，头部标签在下一小节中会有详细介绍。</li>
<li>在<code>\&lt;body\&gt;</code>和<code>\&lt;/body&gt;</code>标签之间的内容是网页的主要内容，如<code>\&lt;h1&gt;、\&lt;p&gt;、\&lt;a&gt;、\&lt;img&gt;</code>等网页内容标签，在这里的标签中的内容会在浏览器中显示出来。</li>
</ol>
<hr>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul>
<li><p>ul…li<br><strong>无序列表</strong>。</p>
<p><code>&lt;u&gt;</code>ul元素中不能放除li的其他标签。但li元素里可以放其他标签<code>&lt;/u&gt;</code></p>
</li>
</ul>
<ul>
<li>ol…li<br><strong>有序列表</strong>。默认从1开始。</li>
</ul>
<ul>
<li><p>dl…dt…dd</p>
<p>自定义列表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dt</span>&gt;</span>概念<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>定义1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>定义2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>网页底部的帮助中心，服务支持列表多为自定义列表</p>
</li>
</ul>
<hr>
<h3 id="逻辑板块"><a href="#逻辑板块" class="headerlink" title="逻辑板块"></a>逻辑板块</h3><ul>
<li>div<br>划分独立的逻辑板块。</li>
<li>span</li>
</ul>
<hr>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3> <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">caption</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">tr</span>&gt;</span>                      //分割每列</span><br><span class="line">  	<span class="tag">&lt;<span class="name">th</span>&gt;</span>表头<span class="tag">&lt;/<span class="name">th</span>&gt;</span>           //表头默认居中粗体</span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>tr里只能有td或th标签，但td和th里可以放其他标签</p>
<p> html属性表格默认无表格线。可通过css添加。</p>
<p>属性  </p>
<ul>
<li>summary：table属性。表格摘要。语义化属性。</li>
<li>border：设置边框宽度。默认为0</li>
<li>cellspacing:设置单元格与单元格边框之间的空白间距。默认为2。</li>
<li>cellpadding：单元格内容和单元格边框之间的空白边距。默认为1。</li>
<li>width</li>
<li>height</li>
<li>align：表格在网页中的水平对齐方式<br>合并属性</li>
</ul>
<ul>
<li>rowspan：跨行合并。参数为共有几格合并一起。</li>
<li>colspan：跨列合并。参数为共有几格合并一起。</li>
</ul>
<hr>
<h3 id="超链接-a"><a href="#超链接-a" class="headerlink" title="超链接 a"></a>超链接 a</h3><ol>
<li>属性<ul>
<li>href：链接地址。</li>
<li>title:此超链接事件的目的。语义化属性。   </li>
<li>target:链接打开方式。默认直接在本窗口打开（self）。<ol>
<li>_blank：打开新窗口。<ol>
<li>view_frame:在制定框架打开。</li>
<li>self:本窗口打开</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<blockquote>
<h5 id="href自动打开默认邮箱的方法"><a href="#href自动打开默认邮箱的方法" class="headerlink" title="href自动打开默认邮箱的方法"></a>href自动打开默认邮箱的方法</h5><p><a href="https://imgchr.com/i/8ikETJ"><img src="https://s2.ax1x.com/2020/03/10/8ikETJ.png" alt="8ikETJ.png"></a><br>1.如果mailto后面同时有多个参数的话，第一个参数必须以“?”开头，后面的参数每一个都以“&amp;”分隔。<br>2.仔细观察可发现，只有mailto后面是加冒号，其余均是等号。</p>
<ol>
<li>锚点定位</li>
</ol>
</blockquote>
<p>实现点击链接后快速跳转到本页面的某内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#id&quot;</span>&gt;</span>内部跳转链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;id&quot;</span>&gt;</span>想要跳转到的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">### base标签\<span class="tag">&lt;<span class="name">base</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">设置整体链接的默认行为。必须在head元素中。</span><br><span class="line"></span><br><span class="line">​```html</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">base</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--所有链接默认新窗口打开--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>属性</p>
<ul>
<li>href：规定所有链接的默认链接</li>
<li>target：规定所有链接默认打开方式</li>
</ul>
<hr>
<h3 id="图片-img"><a href="#图片-img" class="headerlink" title="图片 img"></a>图片 img</h3><p>属性</p>
<ul>
<li><p>单标签</p>
</li>
<li><p>src：图片链接。</p>
</li>
<li>alt：指定图像的描述性文本，当图像不可见时（下载不成功时），可看到该属性指定的文本。</li>
<li>title：提供在图像可见时对图像的描述(鼠标滑过图片时显示的文本)。</li>
<li>border：边框</li>
</ul>
<hr>
<h3 id="表单域-lt-form-gt"><a href="#表单域-lt-form-gt" class="headerlink" title="表单域&lt;form&gt;"></a>表单域<code>&lt;form&gt;</code></h3><p>把浏览者输入的数据传送到服务器端*<br>属性 </p>
<ul>
<li>action ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。<ul>
<li>method ： 数据传送的方式（get/post）。<ul>
<li>get:快速但不安全。会显示在地址栏</li>
<li>post：速度慢但较安全<br>注意<br>所有表单控件（文本框、文本域、按钮、单选框、复选框等）都必须放在 <code>\&lt;form&gt;\&lt;/form&gt;</code>标签之间（否则用户输入的信息提交不到服务器上）</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="表单控件"><a href="#表单控件" class="headerlink" title="表单控件"></a>表单控件</h3><ul>
<li><p><code>\&lt;input /&gt;</code><br>属性</p>
<ul>
<li><p>type：text（文本输入框），button（提交按钮），password（密码输入框），checkbox（复选框），更多点击<a href="https://www.w3cschool.cn/htmltags/att-input-type.html">type属性</a>。</p>
</li>
<li><p>name:为文本框/选择框命名，以对同类的单选框/复选框分组。以备后台程序使用。</p>
</li>
<li><p>value：1.为文本输入框/按钮设置默认文字。2.为选择框提交数据到服务器的值。</p>
</li>
<li><p>checked:选择框使用。当设置 checked=”checked” 时，该选项被默认选中。</p>
</li>
<li><p>size：控件宽度</p>
</li>
<li><p>maxlength:规定输入最多字符数 </p>
</li>
<li><p>reset；重置该表单的所有内容 </p>
</li>
</ul>
</li>
</ul>
<pre><code>`&lt;u&gt;`同类单选框的name要用一样的才能起到效果`&lt;/u&gt;`
</code></pre><ul>
<li><code>\&lt;textarea&gt;</code><br>属性<ul>
<li>cols ：多行输入域的列数。</li>
<li>rows ：多行输入域的行数。<br><em>这两个属性可用css样式的width和height来代替</em></li>
</ul>
</li>
</ul>
<ul>
<li><code>\&lt;label&gt;</code><br><code>\&lt;label&gt;</code>标签为 input 元素定义标注。如果您在 label 元素内点击文本，就会触发此控件。</li>
</ul>
<p>  属性</p>
<ul>
<li><p>for:规定 label 与哪个表单元素绑定(需绑定id）。</p>
<p>方法1:直接包裹input</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">  输入账号：</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<pre><code>          方法2:for固定
</code></pre><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;two&quot;</span>&gt;</span></span><br><span class="line">  输入账号：</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">  输入密码：</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span> =<span class="string">&quot;two&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>下拉菜单<code>\&lt;select&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>显示文字<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>显示文字<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>属性</p>
<ul>
<li><p>value：option属性。向服务器发送值。  </p>
</li>
<li><p>selected：option属性。设置selected=”selected”属性，则该选项就被默认选中。</p>
</li>
<li><p>multiple：select属性。设置multiple=”multiple”时，可以多选。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="文字类"><a href="#文字类" class="headerlink" title="文字类"></a>文字类</h3><ul>
<li>p（段落标签）<br>段落。段落之间会有空白。可用css改变。</li>
<li>hx（标题标签）<br>共有六个等级。h1一般用于网页总标题。</li>
</ul>
<ul>
<li><p>em<br>表示强调。默认为斜体。</p>
</li>
<li><p>i</p>
<p>倾斜字体</p>
<p><code>&lt;u&gt;</code>推荐使用em，有强调的语义<code>&lt;/u&gt;</code></p>
</li>
</ul>
<ul>
<li><p>strong<br>表示更加强调。默认为粗体。</p>
</li>
<li><p>b</p>
<p>加粗。</p>
<p><code>&lt;u&gt;</code>推荐使用strong，有强调的语义<code>&lt;/u&gt;</code></p>
</li>
</ul>
<ul>
<li><p>del</p>
<p>表示强调。默认为删除线。</p>
</li>
<li><p>s</p>
<p>删除线</p>
<p><code>&lt;u&gt;</code>推荐使用del，有强调的语义<code>&lt;/u&gt;</code></p>
</li>
</ul>
<ul>
<li><p>ins</p>
<p>表示强调。默认为下划线。</p>
</li>
<li><p>u</p>
<p>下划线</p>
<p><code>&lt;u&gt;</code>推荐使用ins，有强调的语义<code>&lt;/u&gt;</code></p>
</li>
</ul>
<ul>
<li>span<br>无语义。为了设置css样式而存在。（比如既想设一个单独的style又不想让浏览器将它阅读为段落，强调等意思时。）</li>
<li>q<br>引用。浏览器会为其自动加上双引号。</li>
<li>blockquote<br>长段引用。无引号。前后缩进。</li>
<li>address<br>地址信息。也可以定义一个地址（比如电子邮件地址）、签名或者文档的作者身份。默认换行和斜体。</li>
<li>code<br>一行代码。</li>
<li>pre<br>保留源代码的空格和换行符。常见应用于长段代码。</li>
</ul>
<hr>
<h3 id="文字分割类"><a href="#文字分割类" class="headerlink" title="文字分割类"></a>文字分割类</h3><ul>
<li>br（换行标签）<br>单标签。换行。</li>
<li><code>&amp;nbsp;</code><br>空格</li>
<li>hr（水平线标签）<br>单标签。分割线/水平线</li>
</ul>
<hr>
<h3 id="特殊字符标签"><a href="#特殊字符标签" class="headerlink" title="特殊字符标签"></a>特殊字符标签</h3><p><img src="https://s2.ax1x.com/2020/03/09/89ijFx.png" alt="89ijFx.png"></p>
<hr>
<h2 id="HTML5新增标签"><a href="#HTML5新增标签" class="headerlink" title="HTML5新增标签"></a>HTML5新增标签</h2><h3 id="1-常用新增标签"><a href="#1-常用新增标签" class="headerlink" title="1.常用新增标签"></a>1.常用新增标签</h3><p>逻辑类</p>
<ul>
<li>header：页面头部</li>
<li>footer：页面底部</li>
<li>nav：导航栏</li>
<li>article：文章</li>
<li>section：区域</li>
<li>aside：侧边栏</li>
</ul>
<p>表单类</p>
<ul>
<li><p>datalist:定义选项列表，与input搭配</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">list</span>=<span class="string">&quot;data&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;data&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>刘德华<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>刘若英<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>郭富城<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>datalist不仅具有select下拉菜单的特性（点击下拉按钮会出现列表），还能实现输入字符时有提示列表（类似搜索引擎的那种列表）。在这个代码中，若我输入刘，就会出来刘德华和刘若英。</p>
</li>
<li><p>fieldest:将表单内容包裹起来</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">legend</span>&gt;</span>用户登录<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>密<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/8PhMse"><img src="https://s2.ax1x.com/2020/03/10/8PhMse.png" alt="8PhMse.png"></a></p>
<blockquote>
<p>legend：为fieldest元素定义标题</p>
</blockquote>
</li>
</ul>
<h3 id="2-input-type新增属性值"><a href="#2-input-type新增属性值" class="headerlink" title="2.input type新增属性值"></a>2.input type新增属性值</h3><ul>
<li>email:定义输入邮箱格式。若无@提交时会提醒</li>
<li>tel：定义输入手机格式。手机端会弹出数字键盘。</li>
<li>number：定义输入数字格式。只能输入数字。</li>
<li>url：定义输入网址格式。如果不是网址提交时会提醒。</li>
<li>search：搜索框。输入框后面有一键删除的小叉号。</li>
<li>range：滑块控件。</li>
<li>time:时间输入框。</li>
<li>date：日期输入框。</li>
<li>month：年月输入框。</li>
<li>week：年周输入框。</li>
<li>color：颜色提取框。</li>
</ul>
<h3 id="3-input新增属性"><a href="#3-input新增属性" class="headerlink" title="3.input新增属性"></a>3.input新增属性</h3><ul>
<li>placeholder：占位符。可用来定义输入框内的自带文字，但不影响输入。（与value对比）</li>
<li>autofocus：自动聚焦。用户进入该页面光标自动聚焦该表单控件。</li>
<li>multiple：支持上传多文件。</li>
<li>autocomplete:自动完成已记录内容（提交过一次的）。但是1.必须要有提交按钮2.此表单控件的name值不得为空。</li>
<li>requierd：必填项。聚焦一次后仍为空的话会有提醒。</li>
<li>accesskey：规定快捷键。采用alt+字母的格式。如access=“s”，则快捷键为alt+s。</li>
</ul>
<h3 id="4-多媒体标签"><a href="#4-多媒体标签" class="headerlink" title="4.多媒体标签"></a>4.多媒体标签</h3><ul>
<li><p>embed：网络视频导入常用方法</p>
</li>
<li><p>audio：</p>
<p>属性：</p>
<ul>
<li>autoplay：自动播放</li>
<li>controls：是否显示控件</li>
<li>loop：定义循环播放几次。无限时等于-1</li>
<li>src:路径</li>
</ul>
</li>
<li><p>source:提供不同路径的文件，使浏览器选择可以播放的音频/视频文件。与audio/video搭配使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;horse.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;horse.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class="line"> Your browser does not support the audio element.</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>video:本地视频播放。支持格式：oog,mp4,webm</p>
<p>属性：</p>
<ul>
<li>autoplay：自动播放</li>
<li>controls：是否显示控件</li>
<li>loop：定义循环播放几次。无限时等于-1</li>
<li>src:路径</li>
<li>width:宽度</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript总结</title>
    <url>/2020/03/10/js-memo/</url>
    <content><![CDATA[<blockquote>
<p>《JavaScript DOM编程艺术》</p>
</blockquote>
<h2 id="第二章-准备"><a href="#第二章-准备" class="headerlink" title="第二章 准备"></a>第二章 准备</h2><h3 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h3><ul>
<li>插入方法<br>1.将js代码放到文档<code>&lt;head&gt;</code>中的<code>&lt;script&gt;</code>标签中<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
2.放到文档最后，<code>&lt;/body&gt;</code>之前<strong>（推荐：能使网页加载更快）</strong><blockquote>
<p><code>&lt;script&gt;</code>标签中已经不需要传统的type=”text/javascript”。因为默认即为js。</p>
</blockquote>
</li>
</ul>
<h3 id="2-2-语法"><a href="#2-2-语法" class="headerlink" title="2.2 语法"></a>2.2 语法</h3><h4 id="2-2-3-变量"><a href="#2-2-3-变量" class="headerlink" title="2.2.3 变量"></a>2.2.3 变量</h4><p>1.变量的声明<br><code>var mood;</code><br>2.变量的赋值<br><code>mood=13;</code></p>
<h4 id="2-2-4-数据类型"><a href="#2-2-4-数据类型" class="headerlink" title="2.2.4 数据类型"></a>2.2.4 数据类型</h4><blockquote>
<p>js是弱类型语言，因此不需要声明变量的数据类型。以下的数据类型的变量的声明和赋值语法均相同。</p>
</blockquote>
<p>1.字符串（单引号和双引号均可）<br>2.数值<br>3.布尔值（false或true。不需要引号）<br>4.数组</p>
<ul>
<li>声明<br>1.<code>var sue=Array();</code><br>2.<code>var sue=[];</code></li>
<li>赋值<br>1<code>.var sue=Array(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code><br>2.<code>var sue=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</code><br>3.（已声明的）<code>sue[0]=&quot;a&quot;;</code></li>
<li>关联数组（不推荐使用）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=<span class="title class_">Array</span>();</span><br><span class="line">arr[a]=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">arr[b]=<span class="number">1997</span>;</span><br><span class="line">arr[c]=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
给Array类型的对象添加了三个属性-&gt;应该使用通用对象Object</li>
</ul>
<p>5.对象<br>将关联数组改为<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*obeject第一种创建方式*/</span></span><br><span class="line"><span class="keyword">var</span> arr=<span class="title class_">Object</span>();</span><br><span class="line">arr.<span class="property">a</span>=<span class="string">&quot;a&quot;</span>;</span><br><span class="line">arr.<span class="property">b</span>=<span class="number">1997</span>;</span><br><span class="line">arr.<span class="property">c</span>=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><br>或<strong>花括号创建法</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*object第二种创建方式*/</span></span><br><span class="line"><span class="keyword">var</span> arr=&#123;<span class="attr">a</span>:<span class="string">&quot;a&quot;</span>, <span class="attr">b</span>:<span class="number">1997</span>, c=<span class="literal">false</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>用对象来替代传统数组的意味是可以通过文字而不是数字来引用它们。这大大提高了脚本的可读性。</p>
</blockquote>
<h3 id="2-3-操作"><a href="#2-3-操作" class="headerlink" title="2.3 操作"></a>2.3 操作</h3><ul>
<li>+<br>加号不仅用于运算，也用于字符串的拼接<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Hello</span> = <span class="string">&quot;Good&quot;</span> + <span class="string">&quot;morning&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-函数"><a href="#2-6-函数" class="headerlink" title="2.6 函数"></a>2.6 函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">num1, num2</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> total=num1*num2;</span><br><span class="line">  <span class="title function_">alert</span>(total);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">multiply</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h5 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h5><em>如果某个函数中使用了var，则变量被视为局部变量，只存在于函数中；反之没有使用var，变量会被视为全局变量。且若脚本里已存在一个与之同名的全局变量，这个函数的行为会改变这个全局变量</em></li>
</ul>
<h3 id="2-7-对象"><a href="#2-7-对象" class="headerlink" title="2.7 对象"></a>2.7 对象</h3><ul>
<li>属性：隶属于某个特定对象的变量<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property">age</span>;</span><br></pre></td></tr></table></figure></li>
<li>方法：只有某个特定对象才能调用的函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="title function_">walk</span>();</span><br></pre></td></tr></table></figure></li>
<li>实例：对象的具体个体（<strong>new</strong>关键词）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jenny=<span class="keyword">new</span> <span class="title class_">Person</span>;</span><br><span class="line">jenny.<span class="property">age</span>;</span><br><span class="line">jenny.<span class="title function_">walk</span>();</span><br></pre></td></tr></table></figure>
<h4 id="2-7-1-内建对象"><a href="#2-7-1-内建对象" class="headerlink" title="2.7.1 内建对象"></a>2.7.1 内建对象</h4><h4 id="2-7-2-宿主对象"><a href="#2-7-2-宿主对象" class="headerlink" title="2.7.2 宿主对象"></a>2.7.2 宿主对象</h4></li>
</ul>
<h2 id="第三章-节点"><a href="#第三章-节点" class="headerlink" title="第三章 节点"></a>第三章 节点</h2><h3 id="3-4-节点"><a href="#3-4-节点" class="headerlink" title="3.4 节点"></a>3.4 节点</h3><h4 id="3-4-1-元素节点"><a href="#3-4-1-元素节点" class="headerlink" title="3.4.1 元素节点"></a>3.4.1 元素节点</h4><p>网页文档中的一切元素例如<code>&lt;html&gt;&lt;head&gt;&lt;body&gt;</code></p>
<h4 id="3-4-2-文本节点"><a href="#3-4-2-文本节点" class="headerlink" title="3.4.2 文本节点"></a>3.4.2 文本节点</h4><p>包含有文本的元素节点，其中文本的具体内容称为文本节点。<strong>并非所有元素节点具有文本节点，但所有文本节点一定被包含在元素节点中</strong>。</p>
<h4 id="3-4-3-属性节点"><a href="#3-4-3-属性节点" class="headerlink" title="3.4.3 属性节点"></a>3.4.3 属性节点</h4><p>包含有属性的元素节点，其中属性的具体内容称为属性节点。<strong>并非所有元素节点具有属性节点，但所有属性节点一定被包含在元素节点中</strong>。</p>
<h4 id="3-4-5-获取元素"><a href="#3-4-5-获取元素" class="headerlink" title="3.4.5 获取元素"></a>3.4.5 获取元素</h4><p>1.<strong>getElementById</strong><br>document对象的特有函数。getElementById方法内有一个参数，就是你想获得的元素的id值，这个id值必须放在单引号或双引号内</p>
<blockquote>
<p>document对象是文档的根节点，每张网页都有自己的document对象只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="variable language_">document</span>. <span class="title function_">getElementById</span>(<span class="string">&quot;purchases&quot;</span>);</span><br></pre></td></tr></table></figure><br>这个调用将返回一个对象，这个对象对应着document对象里一个独一无二的元素。<br>事实上，文档中的每一个元素都是一个对象</p>
</blockquote>
<p>2.<strong>getElementsByTagName</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="variable language_">document</span>. <span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>);</span><br></pre></td></tr></table></figure><br>这个调用将返回一个对象数组，每个对象分别对应着document对象中的有着给定标签的一个元素。使用中括号便可分别调用每个对象。<br><strong>特殊</strong>：getElementsByTagName允许把一个通配符作为参数。例如<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> items = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;*&quot;</span>);</span><br></pre></td></tr></table></figure><br>items数组将包含文档中的所有元素节点</p>
<p>3.<strong>getElementsByClassName</strong><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;sale&quot;</span>);</span><br></pre></td></tr></table></figure><br>返回具有相同类名的元素的数组<br><strong>特殊</strong>：可以查找带有多个类名的元素。只要在字符串参数中用空格分割类名即可。（无序匹配）<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;sale important&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="3-5-获取和设置属性"><a href="#3-5-获取和设置属性" class="headerlink" title="3.5 获取和设置属性"></a>3.5 获取和设置属性</h3><h4 id="3-5-1-getAttribute"><a href="#3-5-1-getAttribute" class="headerlink" title="3.5.1 getAttribute"></a>3.5.1 getAttribute</h4><p>getAttribute方法不属于document对象，它只能通过元素节点调用。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">var</span> paras = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;paras.<span class="property">length</span>;i++)&#123;</span><br><span class="line">  <span class="title function_">alert</span>(paras[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>返回对象的指定属性内容</p>
<h4 id="3-5-3-setAttribut"><a href="#3-5-3-setAttribut" class="headerlink" title="3.5.3 setAttribut"></a>3.5.3 setAttribut</h4><p>setAttribute()允许我们对属性节点的值作出修改<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*例*/</span><br><span class="line">var shopping=document.getElementById(&quot;purchases&quot;);</span><br><span class="line">shopping.setAttribute(&quot;title&quot;,&quot;a list of goods&quot;);</span><br></pre></td></tr></table></figure><br>若属性本身并不存在，setAttribute实际完成了两项操作：先创建这个属性，然后设置它的值；如果用于本身就有这个属性的元素节点上，这个属性的值就会被覆盖掉。</p>
<blockquote>
<p>通过setAttribute对文档进行修改后，用浏览器的查看源代码看到的仍然是改变前的属性值。也就是说setAttribute做出的修改并不会反映在文档本身的源代码中。<br>这源于DOM的工作方式：先加载文档的静态内容，再动态刷新，动态刷新并不影响文档的静态内容。</p>
</blockquote>
<h2 id="第五章-最佳实践"><a href="#第五章-最佳实践" class="headerlink" title="第五章 最佳实践"></a>第五章 最佳实践</h2><h3 id="5-2-平稳退化"><a href="#5-2-平稳退化" class="headerlink" title="5.2 平稳退化"></a>5.2 平稳退化</h3><h3 id="5-3-向css学习"><a href="#5-3-向css学习" class="headerlink" title="5.3 向css学习"></a>5.3 向css学习</h3><h4 id="5-3-2-渐进增强"><a href="#5-3-2-渐进增强" class="headerlink" title="5.3.2 渐进增强"></a>5.3.2 渐进增强</h4><h3 id="5-4-分离JavaScript"><a href="#5-4-分离JavaScript" class="headerlink" title="5.4 分离JavaScript"></a>5.4 分离JavaScript</h3><p>类似于使用style属性，在html文档里使用诸如onclick之类的属性也是一种<u>既没效率又容易引发问题的做法</u></p>
<p>我们可以在外部Js文件里把一个事件添加到html文档中的某个元素上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="title function_">getElementById</span>(id).<span class="property">event</span>=action;</span><br></pre></td></tr></table></figure>
<p>当我们想让一个链接从新窗口打开，我们可以用onclick和open（）配合，并阻止浏览器的默认行为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="keyword">var</span> links= <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;links.<span class="property">length</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span> (links[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;class&quot;</span>)==<span class="string">&quot;popup&quot;</span>)&#123;</span><br><span class="line">		links[i].<span class="property">onclick</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">			<span class="title function_">popup</span>(<span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&quot;href&quot;</span>));</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pop</span>(<span class="params">winURL</span>)&#123;</span><br><span class="line">	<span class="variable language_">window</span>.<span class="title function_">open</span>(winURL,<span class="string">&quot;popup&quot;</span>,<span class="string">&quot;width=320,height=480&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有个问题需要解决：如果把这段代码放入外部文件，他们将无法正常运行，因为它很可能在文档加载完成前被加载。没有完整的DOM,getElementById等方法就不能正常工作。</p>
<p>必须让这些代码在HTML文档全部加载到浏览器之后马上开始执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=prepareLinks;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">prepareLinks</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> links= <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;links.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (links[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;class&quot;</span>)==<span class="string">&quot;popup&quot;</span>)&#123;</span><br><span class="line">      links[i].<span class="property">onclick</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">popup</span>(<span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&quot;href&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pop</span>(<span class="params">winURL</span>)&#123;</span><br><span class="line">	<span class="variable language_">window</span>.<span class="title function_">open</span>(winURL,<span class="string">&quot;popup&quot;</span>,<span class="string">&quot;width=320,height=480&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-5-向后兼容"><a href="#5-5-向后兼容" class="headerlink" title="5.5 向后兼容"></a>5.5 向后兼容</h3><h4 id="5-5-1-对象检测"><a href="#5-5-1-对象检测" class="headerlink" title="5.5.1 对象检测"></a>5.5.1 对象检测</h4><p>针对浏览器不支持js的问题，最简单的解决方法是检测浏览器对js的支持程度：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">getElementbyId</span>)&#123;</span><br><span class="line">		statement using getElementById</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在使用对象检测时，方法后面的圆括号一定要删掉</p>
</blockquote>
<p>如此一来造成的后果是我们会增加一对花括号，为了方便阅读和理解，将测试条件改为”如果你不理解请离开”更为易懂</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*例*/</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=prepareLinks;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">prepareLinks</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="variable language_">document</span>.<span class="property">getElementByTagName</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">var</span> links= <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;links.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (links[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;class&quot;</span>)==<span class="string">&quot;popup&quot;</span>)&#123;</span><br><span class="line">      links[i].<span class="property">onclick</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">popup</span>(<span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&quot;href&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pop</span>(<span class="params">winURL</span>)&#123;</span><br><span class="line">	<span class="variable language_">window</span>.<span class="title function_">open</span>(winURL,<span class="string">&quot;popup&quot;</span>,<span class="string">&quot;width=320,height=480&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-6-性能考虑"><a href="#5-6-性能考虑" class="headerlink" title="5.6 性能考虑"></a>5.6 性能考虑</h3><h4 id="5-6-1-尽量少访问DOM和尽量减少标记"><a href="#5-6-1-尽量少访问DOM和尽量减少标记" class="headerlink" title="5.6.1 尽量少访问DOM和尽量减少标记"></a>5.6.1 尽量少访问DOM和尽量减少标记</h4><p>1.避免重复用DOM函数做同一件事，更好的处理方法是使用变量储存他们</p>
<p>2.避免在文档中做太多标记，增加DOM搜索的工作量</p>
<h4 id="5-6-2-合并和放置脚本"><a href="#5-6-2-合并和放置脚本" class="headerlink" title="5.6.2 合并和放置脚本"></a>5.6.2 合并和放置脚本</h4><p>1.尽量把多个js文件合并成一个文件，减少请求数量</p>
<p>2.把脚本放置于<code>&lt;/body&gt;</code>前，加快文档加载</p>
<h4 id="5-6-3-压缩脚本"><a href="#5-6-3-压缩脚本" class="headerlink" title="5.6.3 压缩脚本"></a>5.6.3 压缩脚本</h4><p>利用软件删除不必要的注释空格，缩短变量名。</p>
<ul>
<li>优点：减小文件大小</li>
<li>缺点：大大降低可读性</li>
<li>解决方法：准备两个版本，精简版本上传，正常版本本地修改</li>
</ul>
<h2 id="第七章-动态创建标记"><a href="#第七章-动态创建标记" class="headerlink" title="第七章 动态创建标记"></a>第七章 动态创建标记</h2><h3 id="7-1-一些传统方法"><a href="#7-1-一些传统方法" class="headerlink" title="7.1 一些传统方法"></a>7.1 一些传统方法</h3><h4 id="7-1-1-document-write"><a href="#7-1-1-document-write" class="headerlink" title="7.1.1 document.write"></a>7.1.1 document.write</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">		documrnt.write(&quot;<span class="tag">&lt;<span class="name">p</span>&gt;</span>This is inserted.<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&quot;)</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">	</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>document.write最大的缺点是他违背了行为应该与表现分离的原则。我们应该避免使用它。</p>
<h4 id="7-1-2-innerHTML属性"><a href="#7-1-2-innerHTML属性" class="headerlink" title="7.1.2 innerHTML属性"></a>7.1.2 innerHTML属性</h4><p>当想插入文档一段话时就可以使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">testdiv.<span class="property">innerHTML</span>=<span class="string">&quot;&lt;p&gt;I inserted &lt;em&gt;this&lt;/em&gt; 	content.&lt;/p&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>但是这个技术无法区分插入一段内容和修改一段内容。即使原文档有内容，最终效果也是一样的。</p>
<p>而DOM就可以提供更为精确的方法和属性。</p>
<h3 id="7-2-DOM方法"><a href="#7-2-DOM方法" class="headerlink" title="7.2 DOM方法"></a>7.2 DOM方法</h3><blockquote>
<p>在DOM看来，一个文档就是一棵节点树。你并不是在创建标记，而实在改变DOM节点树。</p>
</blockquote>
<h4 id="7-2-1-createElement方法"><a href="#7-2-1-createElement方法" class="headerlink" title="7.2.1 createElement方法"></a>7.2.1 createElement方法</h4><p>当我们想在testdiv中添加一个p元素节点时，我们要做两件事</p>
<p>1.创建一个新的元素</p>
<p>2.把这个新元素插入节点树</p>
<p>创建元素由creatElement完成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> para=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>现在pare包含一个指向刚创建的元素的引用。这个p虽然已经存在了，但它还不是任何一棵DOM节点树的组成，它只是游荡在JavaScript世界里的一个孤儿。这种情况被称为<strong><em>文档碎片</em></strong>，还无法显示在浏览器的窗口画面里。</p>
<h4 id="7-2-2-appendChild方法"><a href="#7-2-2-appendChild方法" class="headerlink" title="7.2.2 appendChild方法"></a>7.2.2 appendChild方法</h4><p>把新创建的节点插入到元素节点的子节点中；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> para=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> testdiv = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;testdiv&quot;</span>);</span><br><span class="line">testdiv.<span class="title function_">appendChild</span>(<span class="string">&quot;para&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="7-2-3-creatTextNode方法"><a href="#7-2-3-creatTextNode方法" class="headerlink" title="7.2.3 creatTextNode方法"></a>7.2.3 creatTextNode方法</h4><p>现在我们想把一些文本放入到p元素中，但creatElement方法帮不上忙，它只能创建元素节点。你需要创建一个文本节点，createTextNode可以做到:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> txt=<span class="variable language_">document</span>.<span class="title function_">creatTextNode</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>与creatElement的性质一样，现在变量txt包含指向新创建的文本节点的引用。这个节点现在也是js世界的一个孤儿，它还未被插入到任何一个文档的节点树。</p>
<p>appendChild依然可以帮我们插入它到p元素节点中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">para.<span class="title function_">appendChild</span>(txt);</span><br></pre></td></tr></table></figure>
<h4 id="7-2-4-一个更复杂的组合"><a href="#7-2-4-一个更复杂的组合" class="headerlink" title="7.2.4 一个更复杂的组合"></a>7.2.4 一个更复杂的组合</h4><p><img src="https://s2.ax1x.com/2020/02/13/1qTZgH.png" alt="思路"></p>
<p>根据上述步骤编写出来的js代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> para=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> txt1=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;This is &quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> emphasis=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;em&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> txt2=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;my &quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> txt3=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;content.&quot;</span>);</span><br><span class="line">	para.<span class="title function_">appendChild</span>(txt1);</span><br><span class="line">	emphasis.<span class="title function_">appendChild</span>(txt2);</span><br><span class="line">	para.<span class="title function_">appendChild</span>(emphasis);</span><br><span class="line">	para.<span class="title function_">appendChild</span>(txt3);</span><br><span class="line">	<span class="keyword">var</span> testdiv=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;testdiv&quot;</span>);</span><br><span class="line">	testdiv.<span class="title function_">appendChild</span>(para);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-4-Ajax"><a href="#7-4-Ajax" class="headerlink" title="7.4 Ajax"></a>7.4 Ajax</h3><p>Ajax可以只更新页面的一部分内容，而不会打断用户的浏览体验</p>
<h4 id="7-4-1-XMLHttpRequest对象"><a href="#7-4-1-XMLHttpRequest对象" class="headerlink" title="7.4.1 XMLHttpRequest对象"></a>7.4.1 XMLHttpRequest对象</h4><p>没看懂</p>
<h4 id="7-4-3-Hijax"><a href="#7-4-3-Hijax" class="headerlink" title="7.4.3 Hijax"></a>7.4.3 Hijax</h4><h2 id="第八章-充实文档的内容（explanation）"><a href="#第八章-充实文档的内容（explanation）" class="headerlink" title="第八章 充实文档的内容（explanation）"></a>第八章 充实文档的内容（explanation）</h2><h3 id="8-1-不应该做什么"><a href="#8-1-不应该做什么" class="headerlink" title="8.1 不应该做什么"></a>8.1 不应该做什么</h3><p>不要用js把一些重要的内容添加在网页上。那些缺乏js的用户永远看不到，而且搜索引擎的机器人也检测不到js内容。</p>
<h3 id="8-3-内容"><a href="#8-3-内容" class="headerlink" title="8.3 内容"></a>8.3 内容</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>What is the Document Object Model&gt;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>The <span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;World Wide Web Consortium&quot;</span>&gt;</span>W3C<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span> defines the <span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;Document Object Model&quot;</span>&gt;</span>DOM<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span> as :<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">blockquote</span> <span class="attr">cite</span>=<span class="string">&quot;http://www.w3.org/DOM/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>A platform- and language-neutral interface that will allow programs and scripts to dynamically access and update the content,structure and style of documents.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">blockquote</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>It is an <span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;Application Programming Interface&quot;</span>&gt;</span>API<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span> that can be used to navigate <span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;Hypertext Markup Language&quot;</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span> and <span class="tag">&lt;<span class="name">abbr</span> <span class="attr">title</span>=<span class="string">&quot;eXtensible Markup Language&quot;</span>&gt;</span>XML<span class="tag">&lt;/<span class="name">abbr</span>&gt;</span> documents.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./test.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><abbr></p>
<p>缩略语</p>
</blockquote>
<h4 id="8-3-2-css"><a href="#8-3-2-css" class="headerlink" title="8.3.2 css"></a>8.3.2 css</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">	<span class="attribute">font-family</span>: <span class="string">&quot;Helvetica&quot;</span>,<span class="string">&quot;Arial&quot;</span>,sans-serif;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">10pt</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">abbr</span>&#123;</span><br><span class="line">	<span class="attribute">text-decoration</span>: none;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">font-style</span>: normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-显示缩略语列表"><a href="#8-4-显示缩略语列表" class="headerlink" title="8.4 显示缩略语列表"></a>8.4 显示缩略语列表</h3><p><img src="https://s2.ax1x.com/2020/02/14/1X4RWF.png" alt="1X4RWF.png"></p>
<p>1.遍历这份文档中的所有abbr元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> abbreviations=<span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;abbr&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(abbreviations.<span class="property">length</span>&lt;<span class="number">1</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不一定所有文档都有缩略语，当没有缩略语时立刻停止这个函数</p>
<p>2.3.保存每个abbr元素的title和包含的文本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> defs=<span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;abbreviations.<span class="property">length</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">var</span> definition=abbreviations[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> key=abbreviations[i].<span class="property">lastChild</span>.<span class="property">nodeValue</span>;</span><br><span class="line">	defs[key]=definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书中方法将title和文本形成了关联数组。</p>
<p>而关于文本部分，根据缩略语的特性，前端很可能将它放在<code>&lt;em&gt;&lt;/em&gt;</code>中来做提示，因此用lastChild比较保险</p>
<p>4.创建一个定义列表元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dlist=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;dl&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>5.6.7.8.9.10.11</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(key <span class="keyword">in</span> defs)&#123;</span><br><span class="line">	<span class="keyword">var</span> definition=defs[key];</span><br><span class="line">	<span class="keyword">var</span> dtitle=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;dt&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> dtitle_text=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(key);</span><br><span class="line">	dtitle.<span class="title function_">appendChild</span>(dtitle_text);</span><br><span class="line">	<span class="keyword">var</span> ddesc=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> ddesc_text=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(definition);</span><br><span class="line">	ddesc.<span class="title function_">appendChild</span>(ddesc_text);</span><br><span class="line">	dlist.<span class="title function_">appendChild</span>(dtitle);</span><br><span class="line">	dlist.<span class="title function_">appendChild</span>(ddesc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>for/in循环：</p>
<p>遍历关联数组/对象的每个属性。</p>
</blockquote>
<p>12.插入这个列表元素</p>
<p>直接插入有些突兀，我们可以在他之前先加一个h2标题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> header=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;h2&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> header_text=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Abbreviations&quot;</span>);</span><br><span class="line">header.<span class="title function_">appendChild</span>(header_text);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(header);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(dlist);</span><br></pre></td></tr></table></figure>
<p>至此，按照步骤这个函数已经初步完成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">displayAbbreviations</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> abbreviations=<span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;abbr&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(abbreviations.<span class="property">length</span>&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> defs=<span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;abbreviations.<span class="property">length</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">var</span> definition=abbreviations[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> key=abbreviations[i].<span class="property">lastChild</span>.<span class="property">nodeValue</span>;</span><br><span class="line">		defs[key]=definition;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> dlist=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;dl&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(key <span class="keyword">in</span> defs)&#123;</span><br><span class="line">		<span class="keyword">var</span> definition=defs[key];</span><br><span class="line">		<span class="keyword">var</span> dtitle=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;dt&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> dtitle_text=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(key);</span><br><span class="line">		dtitle.<span class="title function_">appendChild</span>(dtitle_text);</span><br><span class="line">		<span class="keyword">var</span> ddesc=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> ddesc_text=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(definition);</span><br><span class="line">		ddesc.<span class="title function_">appendChild</span>(ddesc_text);</span><br><span class="line">		dlist.<span class="title function_">appendChild</span>(dtitle);</span><br><span class="line">		dlist.<span class="title function_">appendChild</span>(ddesc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> header=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;h2&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> header_text=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Abbreviations&quot;</span>);</span><br><span class="line">	header.<span class="title function_">appendChild</span>(header_text);</span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(header);</span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(dlist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这个函数还有需要改进的部分</p>
<ul>
<li><p>检查兼容性</p>
<p>1.DOM方法存在性的检测</p>
<p>2.添加注释</p>
<p>3.添加addEvent.js文件</p>
<p>4.将两个js文件关联到文档中</p>
</li>
</ul>
<p>完成以上步骤后最终函数为（addLoadEvent文件省略）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">displayAbbreviations</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="comment">//对象检测</span></span><br><span class="line">	<span class="keyword">if</span>(!<span class="variable language_">document</span>.<span class="property">getElementsByTagName</span> || !<span class="variable language_">document</span>.<span class="property">createElement</span> </span><br><span class="line">		|| !<span class="variable language_">document</span>.<span class="property">createTextNode</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历abbr及存在性</span></span><br><span class="line">	<span class="keyword">var</span> abbreviations=<span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;abbr&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(abbreviations.<span class="property">length</span>&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//存储title和文本内容</span></span><br><span class="line">	<span class="keyword">var</span> defs=<span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;abbreviations.<span class="property">length</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">var</span> definition=abbreviations[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> key=abbreviations[i].<span class="property">lastChild</span>.<span class="property">nodeValue</span>;</span><br><span class="line">		defs[key]=definition;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建列表，插入文本内容</span></span><br><span class="line">	<span class="keyword">var</span> dlist=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;dl&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(key <span class="keyword">in</span> defs)&#123;</span><br><span class="line">		<span class="keyword">var</span> definition=defs[key];</span><br><span class="line">		<span class="keyword">var</span> dtitle=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;dt&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> dtitle_text=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(key);</span><br><span class="line">		dtitle.<span class="title function_">appendChild</span>(dtitle_text);</span><br><span class="line">		<span class="keyword">var</span> ddesc=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> ddesc_text=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(definition);</span><br><span class="line">		ddesc.<span class="title function_">appendChild</span>(ddesc_text);</span><br><span class="line">		dlist.<span class="title function_">appendChild</span>(dtitle);</span><br><span class="line">		dlist.<span class="title function_">appendChild</span>(ddesc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//向文档插入标题和列表</span></span><br><span class="line">	<span class="keyword">var</span> header=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;h2&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> header_text=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Abbreviations&quot;</span>);</span><br><span class="line">	header.<span class="title function_">appendChild</span>(header_text);</span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(header);</span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(dlist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是没有用书本的关联数组的我自己的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span>=<span class="keyword">function</span> <span class="title function_">displayAbbreviations</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> abbr=<span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;abbr&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> defs=<span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">	<span class="keyword">var</span> key=<span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;abbr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">		defs[i]=abbr[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">		key[i]=abbr[i].<span class="property">firstChild</span>.<span class="property">nodeValue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> dl=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;dl&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;abbr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">var</span> dt=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;dt&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> dt_title=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(key[i]);</span><br><span class="line">		dt.<span class="title function_">appendChild</span>(dt_title);</span><br><span class="line">		<span class="keyword">var</span> dd=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> dd_title=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(defs[i]);</span><br><span class="line">		dd.<span class="title function_">appendChild</span>(dd_title);</span><br><span class="line">		dl.<span class="title function_">appendChild</span>(dt);</span><br><span class="line">		dl.<span class="title function_">appendChild</span>(dd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(dl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-3-一个浏览器的地雷"><a href="#8-4-3-一个浏览器的地雷" class="headerlink" title="8.4.3 一个浏览器的地雷"></a>8.4.3 一个浏览器的地雷</h4><p>在IE7之前是不支持abbr文法的，因此js无法获取abbr元素节点。</p>
<p>我们应该实现函数的平稳退化。</p>
<p>由于IE浏览器在统计abbr元素的子节点个数时总会返回一个错误值—-0。因此我们添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;abbreviations.<span class="property">length</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(abbreviations[i].<span class="property">childNodes</span>.<span class="property">length</span>&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> definition=abbreviations[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> key=abbreviations[i].<span class="property">lastChild</span>.<span class="property">nodeValue</span>;</span><br><span class="line">	defs[key]=definition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为要检测abbr元素的子节点个数，而不是数组的子节点，因此要在for文中检测。并且要保证所有的abbr元素节点都不存在，才是真的在ie前期版本中。因此这里用的是continue而不是false。</p>
<p>以及在第二个for文后：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(dlist.<span class="property">childNodes</span>.<span class="property">length</span>&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>如果所有abbr元素节点都不存在，那第二个for文根本无法执行（defs为空），因此如果dlist中没有子节点，则结束函数，说明这个浏览器真的不支持abbr。</p>
<p>最终完成函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">displayAbbreviations</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="comment">//对象检测</span></span><br><span class="line">	<span class="keyword">if</span>(!<span class="variable language_">document</span>.<span class="property">getElementsByTagName</span> || !<span class="variable language_">document</span>.<span class="property">createElement</span> </span><br><span class="line">		|| !<span class="variable language_">document</span>.<span class="property">createTextNode</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//遍历abbr及存在性</span></span><br><span class="line">	<span class="keyword">var</span> abbreviations=<span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;abbr&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(abbreviations.<span class="property">length</span>&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//存储title和文本内容</span></span><br><span class="line">	<span class="keyword">var</span> defs=<span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;abbreviations.<span class="property">length</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(abbreviations[i].<span class="property">childNodes</span>.<span class="property">length</span>&lt;<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> definition=abbreviations[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> key=abbreviations[i].<span class="property">lastChild</span>.<span class="property">nodeValue</span>;</span><br><span class="line">		defs[key]=definition;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建列表，插入文本内容</span></span><br><span class="line">	<span class="keyword">var</span> dlist=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;dl&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(key <span class="keyword">in</span> defs)&#123;</span><br><span class="line">		<span class="keyword">var</span> definition=defs[key];</span><br><span class="line">		<span class="keyword">var</span> dtitle=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;dt&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> dtitle_text=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(key);</span><br><span class="line">		dtitle.<span class="title function_">appendChild</span>(dtitle_text);</span><br><span class="line">		<span class="keyword">var</span> ddesc=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> ddesc_text=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(definition);</span><br><span class="line">		ddesc.<span class="title function_">appendChild</span>(ddesc_text);</span><br><span class="line">		dlist.<span class="title function_">appendChild</span>(dtitle);</span><br><span class="line">		dlist.<span class="title function_">appendChild</span>(ddesc);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dlist.<span class="property">childNodes</span>.<span class="property">length</span>&lt;<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//向文档插入标题和列表</span></span><br><span class="line">	<span class="keyword">var</span> header=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;h2&quot;</span>);</span><br><span class="line">	<span class="keyword">var</span> header_text=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;Abbreviations&quot;</span>);</span><br><span class="line">	header.<span class="title function_">appendChild</span>(header_text);</span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(header);</span><br><span class="line">	<span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(dlist);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-5-显示文献来源链接表"><a href="#8-5-显示文献来源链接表" class="headerlink" title="8.5 显示文献来源链接表"></a>8.5 显示文献来源链接表</h3><p>1.查找你的元素</p>
<p>查找blackquote元素很简单。以及当这个blackquote没有给出链接时，我们就不必显示链接表：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> quotes=<span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;blockquote&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;quotes.<span class="property">length</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!quotes[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;cite&quot;</span>))&#123;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="keyword">var</span> url=quotes[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;cite&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个问题；我们想把链接显示在引用文献的后面。而blackquote里面还有p元素，我们要把他调用出来。但是在这两个元素之间还有换行符，它也属于节点之一，我们无法直接使用firstchild或lastchild。我们可以先把所有元素找出来，再选取最后一个。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> quotesElements=quotes[i].<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> elem=quotesElements[quotesElements.<span class="property">length</span>-<span class="number">1</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.创建链接</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> links=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> links_text=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;source&quot;</span>);</span><br><span class="line">links.<span class="title function_">appendChild</span>(links_text);</span><br><span class="line">links.<span class="title function_">setAttribute</span>(<span class="string">&quot;href&quot;</span>,url);</span><br></pre></td></tr></table></figure>
<p>3.插入链接</p>
<p>我们可以再插入一个<code>&lt;sup&gt;</code>上标元素，让链接看起来更舒服；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> superscript=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;sup&quot;</span>);</span><br><span class="line">superscript.<span class="title function_">appendChild</span>(links);</span><br><span class="line">elem.<span class="title function_">appendChild</span>(superscript);</span><br></pre></td></tr></table></figure>
<p>最后的完整函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">displayCitations</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> quotes=<span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;blockquote&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;quotes.<span class="property">length</span>;i++)&#123;</span><br><span class="line">		<span class="comment">//DOM对象检测</span></span><br><span class="line">		<span class="keyword">if</span>(!<span class="variable language_">document</span>.<span class="property">getElementsByTagName</span> || !<span class="variable language_">document</span>.<span class="property">createElement</span> </span><br><span class="line">		|| !<span class="variable language_">document</span>.<span class="property">createTextNode</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cite属性存在性检测</span></span><br><span class="line">		<span class="keyword">if</span>(!quotes[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;cite&quot;</span>))&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//调用cite属性</span></span><br><span class="line">		<span class="keyword">var</span> url=quotes[i].<span class="title function_">getAttribute</span>(<span class="string">&quot;cite&quot;</span>);</span><br><span class="line">		<span class="comment">//调用p元素</span></span><br><span class="line">		<span class="keyword">var</span> quotesElements=quotes[i].<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> elem=quotesElements[quotesElements.<span class="property">length</span>-<span class="number">1</span>];</span><br><span class="line">		<span class="comment">//创建链接</span></span><br><span class="line">		<span class="keyword">var</span> links=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> links_text=<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&quot;source&quot;</span>);</span><br><span class="line">		links.<span class="title function_">appendChild</span>(links_text);</span><br><span class="line">		links.<span class="title function_">setAttribute</span>(<span class="string">&quot;href&quot;</span>,url);</span><br><span class="line">		<span class="comment">//插入链接</span></span><br><span class="line">		<span class="keyword">var</span> superscript=<span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;sup&quot;</span>);</span><br><span class="line">		superscript.<span class="title function_">appendChild</span>(links);</span><br><span class="line">		elem.<span class="title function_">appendChild</span>(superscript);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addLoadEvent</span>(displayCitations);</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.ax1x.com/2020/02/15/1x9Qyj.png" alt="1x9Qyj.png"></p>
<h2 id="第九章-CSS-DOM"><a href="#第九章-CSS-DOM" class="headerlink" title="第九章 CSS-DOM"></a>第九章 CSS-DOM</h2><h3 id="9-1-三位一体的网页"><a href="#9-1-三位一体的网页" class="headerlink" title="9.1 三位一体的网页"></a>9.1 三位一体的网页</h3><ul>
<li><p>结构层</p>
<p>HTML，XHTML</p>
</li>
<li><p>表示层</p>
<p>CSS</p>
</li>
<li><p>行为层</p>
<p>Js，DOM</p>
</li>
</ul>
<h3 id="9-2-style属性"><a href="#9-2-style属性" class="headerlink" title="9.2 style属性"></a>9.2 style属性</h3><p>每个元素节点都有一个属性style。style属性包含着元素的样式，查询style属性不会返回一个简单的字符串而是一个对象。往事都被存放在这个style对象里。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.<span class="property">style</span>.<span class="property">property</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">para.<span class="property">style</span>.<span class="property">color</span></span><br></pre></td></tr></table></figure>
<p>而当样式名由连字符时，不管有多少个，都将他们后面的字母变成驼峰命名法。如font-family:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">para.<span class="property">style</span>.<span class="property">fontFamily</span></span><br></pre></td></tr></table></figure>
<p>同样的，background-color对应着backgroundColor，margin-top-width对应着marginTopWidth．</p>
<p>DOM在表示样式属性时采用的单位大部分和css样式表里的设置相同。</p>
<h4 id="内嵌样式"><a href="#内嵌样式" class="headerlink" title="内嵌样式"></a>内嵌样式</h4><p>在外部样式表里生命的样式不会进入style对象，在文档<code>&lt;head&gt;</code>部分里声明的样式也是如此。DOM无法提取到他们的属性。</p>
<h4 id="9-2-2-设置样式"><a href="#9-2-2-设置样式" class="headerlink" title="9.2.2 设置样式"></a>9.2.2 设置样式</h4><p>style对象不仅可以用来调用，还可以设置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">para.<span class="property">style</span>.<span class="property">color</span>=<span class="string">&quot;black&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-何时该用DOM脚本设置样式"><a href="#9-3-何时该用DOM脚本设置样式" class="headerlink" title="9.3 何时该用DOM脚本设置样式"></a>9.3 何时该用DOM脚本设置样式</h3><h4 id="9-3-1-根据元素在节点树里的位置来设置样式（getNextElement）"><a href="#9-3-1-根据元素在节点树里的位置来设置样式（getNextElement）" class="headerlink" title="9.3.1 根据元素在节点树里的位置来设置样式（getNextElement）"></a>9.3.1 根据元素在节点树里的位置来设置样式（getNextElement）</h4><p>比如想找到每个h1元素后面的元素，并改变他的样式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> headers=<span class="variable language_">document</span>.<span class="title function_">getElementByTagName</span>(<span class="string">&quot;h1&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>nextSibling只能找到下一个节点，但不一定是元素节点，我们可以写一个判断函数:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getNextElement</span>(<span class="params">node</span>)&#123;</span><br><span class="line">	<span class="comment">//如果这个节点就是元素节点，直接返回</span></span><br><span class="line">	<span class="keyword">if</span>(node.<span class="property">nodeType</span>==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果存在下一个节点且不为元素节点，继续递归下一个</span></span><br><span class="line">	<span class="keyword">if</span>(node.<span class="property">nextSibling</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="title function_">getNextElement</span>(node.<span class="property">nextSibling</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//下一个节点不存在</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> elem=<span class="title function_">getNextElement</span>(headers[i].<span class="property">nextSibling</span>);</span><br></pre></td></tr></table></figure>
<p>这样我们就可以设置h1后面的元素elem的样式了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">elem.<span class="property">style</span>.<span class="property">fontWeight</span>=<span class="string">&quot;bold&quot;</span>;</span><br><span class="line">elem.<span class="property">style</span>.<span class="property">fontSize</span>=<span class="string">&quot;1.2em&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="9-3-2-根据某种条件反复设置某种样式"><a href="#9-3-2-根据某种条件反复设置某种样式" class="headerlink" title="9.3.2 根据某种条件反复设置某种样式"></a>9.3.2 根据某种条件反复设置某种样式</h4><p>js非常擅长利用for遍历所有元素。</p>
<h4 id="9-3-3-响应事件"><a href="#9-3-3-响应事件" class="headerlink" title="9.3.3 响应事件"></a>9.3.3 响应事件</h4><p>CSS中有许多伪属性使我们可以进行时间（:hover等），但不同浏览器对他们的支持程度不一，但却对js完美支持。这种情况我们应该考虑：</p>
<ul>
<li>这个问题最简单的解决方案是什么</li>
<li>哪种解决方案会得到更多浏览器的支持</li>
</ul>
<h3 id="9-4-className属性"><a href="#9-4-className属性" class="headerlink" title="9.4 className属性"></a>9.4 className属性</h3><p>比如之前的修改h1标题后的元素节点：我们可以有更简单的方式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.intro</span>&#123;</span><br><span class="line">	<span class="attribute">font-weight</span>:bold;</span><br><span class="line">	<span class="attribute">font-size</span>:<span class="number">1.2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">elem.<span class="title function_">setAttribute</span>(<span class="string">&quot;class&quot;</span>,<span class="string">&quot;intro&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>就可以达到同样的效果。</p>
<p>而还有更简单的方法是更新className属性。这是个可读可写的属性，凡是元素节点就有这个属性。上面的语法可以写成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">elem.<span class="property">className</span>=<span class="string">&quot;intro&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>如果我们想保留原class的样式，可以变为(请注意，第一个字符为空格)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">elem.<span class="property">className</span>+=<span class="string">&quot; intro&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>以上，我们可以封装一个函数addClass：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addClass</span>(<span class="params">element,value</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(element.<span class="property">className</span>==<span class="variable constant_">NULL</span>)&#123;</span><br><span class="line">		element.<span class="property">className</span>=value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		element.<span class="property">className</span>+=<span class="string">&quot; &quot;</span>;</span><br><span class="line">		element.<span class="property">className</span>+=value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这确保了表示层和行为层分离的更加彻底。</p>
<h4 id="对函数进行抽象"><a href="#对函数进行抽象" class="headerlink" title="对函数进行抽象"></a>对函数进行抽象</h4><p>再如刚才的对h1后面元素的样式进行改变的函数，与其让他们定死为h1和intro，不如将他们封装为函数，这样以后同样的操作时我们也能使用。</p>
<h2 id="第十章-用JavaScript实现动画效果"><a href="#第十章-用JavaScript实现动画效果" class="headerlink" title="第十章 用JavaScript实现动画效果"></a>第十章 用JavaScript实现动画效果</h2><h4 id="10-1-1-位置"><a href="#10-1-1-位置" class="headerlink" title="10.1.1 位置"></a>10.1.1 位置</h4><p>首先设置一个元素的位置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">positionMessage</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="variable language_">document</span>.<span class="property">getElementById</span> || !<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;message&quot;</span>))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> elem=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">	elem.<span class="property">style</span>.<span class="property">position</span>=<span class="string">&quot;absolute&quot;</span>;</span><br><span class="line">	elem.<span class="property">style</span>.<span class="property">left</span>=<span class="string">&quot;50px&quot;</span>;</span><br><span class="line">	elem.<span class="property">style</span>.<span class="property">top</span>=<span class="string">&quot;100px&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想去移动也很简单</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">moveMessage</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="variable language_">document</span>.<span class="property">getElementById</span> || !<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;message&quot;</span>))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> elem=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">	elem.<span class="property">style</span>.<span class="property">left</span>=<span class="string">&quot;200px&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addLoadEvent</span>(positionMessage);</span><br><span class="line"><span class="title function_">addLoadEvent</span>(moveMessage);</span><br></pre></td></tr></table></figure>
<p>但这样最终呈现的没有动的过程。</p>
<h4 id="10-1-2-时间-setTimeout-clearTimeout"><a href="#10-1-2-时间-setTimeout-clearTimeout" class="headerlink" title="10.1.2 时间(setTimeout,clearTimeout)"></a>10.1.2 时间(setTimeout,clearTimeout)</h4><p>setTimeout能够让某个函数在经过一段预定的时间后才开始执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="string">&quot;function&quot;</span>,interval);</span><br></pre></td></tr></table></figure>
<p>第一个参数是字符串，为执行函数的名字。第二个参数是以毫秒为单位的预定时间。</p>
<p>与之相对的，还有一个可以取消这个函数的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">clearTimeout</span>(variable);</span><br></pre></td></tr></table></figure>
<p>他可以取消setTimeout在等待期间取消其行为。参数为保存着setTimeout函数的返回值的变量。</p>
<p>之前的函数我们可以改为:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">positionMessage</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="variable language_">document</span>.<span class="property">getElementById</span> || !<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;message&quot;</span>))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> elem=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">	elem.<span class="property">style</span>.<span class="property">position</span>=<span class="string">&quot;absolute&quot;</span>;</span><br><span class="line">	elem.<span class="property">style</span>.<span class="property">left</span>=<span class="string">&quot;50px&quot;</span>;</span><br><span class="line">	elem.<span class="property">style</span>.<span class="property">top</span>=<span class="string">&quot;100px&quot;</span>;</span><br><span class="line">	movement=<span class="built_in">setTimeout</span>(<span class="string">&quot;moveMessage()&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">addLoadEvent</span>(positionMessage);</span><br></pre></td></tr></table></figure>
<p>setTimeout已经被执行，movement只是保存着这个函数返回值。而这时如果我执行<code>clearTimeout(movement);</code>就可以取消这个行为。</p>
<p>并且，<strong>movement我没有加var，因此他是全局变量</strong>。我可以随时在外部停止他。</p>
<h4 id="10-1-3-时间递增量"><a href="#10-1-3-时间递增量" class="headerlink" title="10.1.3 时间递增量"></a>10.1.3 时间递增量</h4><p>1.获得元素的当前位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elem=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;message&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> xpos=<span class="built_in">parseInt</span>(elem.<span class="property">style</span>.<span class="property">left</span>);</span><br><span class="line"><span class="keyword">var</span> ypos=<span class="built_in">parseInt</span>(elem.<span class="property">style</span>.<span class="property">top</span>);</span><br></pre></td></tr></table></figure>
<p>2.如果已经到达目的地，则退出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(xpos==<span class="number">200</span> &amp;&amp; ypos==<span class="number">100</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.如果尚未到达，则再移近一点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(xpos&lt;<span class="number">200</span>)&#123;</span><br><span class="line">			xpos++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(xpos&gt;<span class="number">200</span>)&#123;</span><br><span class="line">			xpos--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ypos&lt;<span class="number">100</span>)&#123;</span><br><span class="line">			ypos++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ypos&gt;<span class="number">100</span>)&#123;</span><br><span class="line">			ypos--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	elem.<span class="property">style</span>.<span class="property">left</span>=xpos+<span class="string">&quot;px&quot;</span>;<span class="comment">//注意这里</span></span><br><span class="line">	elem.<span class="property">style</span>.<span class="property">top</span>=ypos+<span class="string">&quot;px&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>4.经过一段间隔后重复上述步骤</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">movement=<span class="built_in">setTimeout</span>(<span class="string">&quot;moveMessage()&quot;</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h4 id="10-1-4-抽象"><a href="#10-1-4-抽象" class="headerlink" title="10.1.4 抽象"></a>10.1.4 抽象</h4><p>首先把很明显能发现的元素id，目的地等抽象化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="variable language_">document</span>.<span class="property">getElementById</span> || !<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(elementID))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> elem=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(elementID);</span><br><span class="line">	<span class="keyword">var</span> xpos=<span class="built_in">parseInt</span>(elem.<span class="property">style</span>.<span class="property">left</span>);</span><br><span class="line">	<span class="keyword">var</span> ypos=<span class="built_in">parseInt</span>(elem.<span class="property">style</span>.<span class="property">top</span>);</span><br><span class="line">	<span class="keyword">if</span>(xpos==final_x &amp;&amp; ypos==final_y)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(xpos&lt;final_x)&#123;</span><br><span class="line">			xpos++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(xpos&gt;final_x)&#123;</span><br><span class="line">			xpos--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ypos&lt;final_y)&#123;</span><br><span class="line">			ypos++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ypos&gt;final_y)&#123;</span><br><span class="line">			ypos--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	elem.<span class="property">style</span>.<span class="property">left</span>=xpos+<span class="string">&quot;px&quot;</span>;</span><br><span class="line">	elem.<span class="property">style</span>.<span class="property">top</span>=ypos+<span class="string">&quot;px&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>但是接下来出现了问题：使用setTimeout函数要重新写函数名，这么多参数要怎么办？</p>
<p>首先明确，elementID是字符串，要多出一个引号，因此写法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> repeat=<span class="string">&quot;moveElement(&#x27;&quot;</span>+elementID+<span class="string">&quot;&#x27;,&quot;</span>+final_x+<span class="string">&quot;,&quot;</span>+final_y+<span class="string">&quot;,&quot;</span>+interval+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">movement=<span class="built_in">setTimeout</span>(repeat,interval);</span><br></pre></td></tr></table></figure>
<p>最终函数为；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">moveElement</span>(<span class="params">elementID,final_x,final_y,interval</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="variable language_">document</span>.<span class="property">getElementById</span> || !<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(elementID))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> elem=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(elementID);</span><br><span class="line">	<span class="keyword">var</span> xpos=<span class="built_in">parseInt</span>(elem.<span class="property">style</span>.<span class="property">left</span>);</span><br><span class="line">	<span class="keyword">var</span> ypos=<span class="built_in">parseInt</span>(elem.<span class="property">style</span>.<span class="property">top</span>);</span><br><span class="line">	<span class="keyword">if</span>(xpos==final_x &amp;&amp; ypos==final_y)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(xpos&lt;final_x)&#123;</span><br><span class="line">			xpos++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(xpos&gt;final_x)&#123;</span><br><span class="line">			xpos--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ypos&lt;final_y)&#123;</span><br><span class="line">			ypos++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ypos&gt;final_y)&#123;</span><br><span class="line">			ypos--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	elem.<span class="property">style</span>.<span class="property">left</span>=xpos+<span class="string">&quot;px&quot;</span>;</span><br><span class="line">	elem.<span class="property">style</span>.<span class="property">top</span>=ypos+<span class="string">&quot;px&quot;</span>;</span><br><span class="line">	<span class="keyword">var</span> repeat=<span class="string">&quot;moveElement(&#x27;&quot;</span>+elementID+<span class="string">&quot;&#x27;,&quot;</span>+final_x+<span class="string">&quot;,&quot;</span>+final_y+<span class="string">&quot;,&quot;</span>+interval+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">	movement=<span class="built_in">setTimeout</span>(repeat,interval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-2-实用的动画"><a href="#10-2-实用的动画" class="headerlink" title="10.2 实用的动画"></a>10.2 实用的动画</h3><h4 id="10-2-1-提出问题"><a href="#10-2-1-提出问题" class="headerlink" title="10.2.1 提出问题"></a>10.2.1 提出问题</h4><p>我们希望有一个网页的三个链接，当我们鼠标在链接上时，我们能看见他们的缩略图</p>
<h4 id="10-2-4-JavaScript"><a href="#10-2-4-JavaScript" class="headerlink" title="10.2.4 JavaScript"></a>10.2.4 JavaScript</h4><p>我们可以用一个包含四个缩略图的长图，当在某个链接上时使长图移动，并配合overflow属性，只显示出一个缩略图，达成滚动图效果。</p>
<hr>
<h2 id="后记-本书中的一些注意事项"><a href="#后记-本书中的一些注意事项" class="headerlink" title="后记-本书中的一些注意事项"></a>后记-本书中的一些注意事项</h2><p>1.addLoadEvent.js</p>
<p>在html中的script宣言里，必须放在其他js文件之前。不然浏览器会报错。</p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>【项目实战】基于跨域学习的行人重识别</title>
    <url>/2022/01/17/person-reid-wirh-domain-adaptation/</url>
    <content><![CDATA[<p><a href="/butterfly/passengers.pdf">pdflink<a><br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h5vvqbj2hfj20l007zdgu.jpg" alt=""></p>
<h1 id="基于域学习的行人重识别"><a href="#基于域学习的行人重识别" class="headerlink" title="基于域学习的行人重识别"></a>基于域学习的行人重识别</h1><h1 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h1><p>偏工业项目。主要针对解决公交车的出入口行人重识别课题，来达到自动判断乘客的乘车区间的目的。难点有三：1. 本数据集的出入口的摄像机种类不同（RGB和近红外线） 2. 为保护隐私分辨率较低无法使用面部特征 3. 外部光照影响较大。数据集来源为日本公交公司。</p>
<p><img src="https://p.ipic.vip/ncpwis.png" alt=""></p>
<h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>难点的关键在于我们无法使用过去的方法：颜色特征和面部特征。因此解决的关键是实现提取颜色光照无关的特征（更深层的特征，或域无关的特征）。考虑了以下三种解决方法：</p>
<ol>
<li>利用深度网络学习域无关特征（DANN，AGW）</li>
<li>手动提取域无关特征（HeadReID）</li>
<li>姿态估计（TODO）</li>
</ol>
<h2 id="DANN-1"><a href="#DANN-1" class="headerlink" title="DANN [1]"></a>DANN [1]</h2><p><img src="https://p.ipic.vip/d703om.png" alt=""></p>
<p>在一般的分类预测期以外加上了域分类器，以提高特征的抽象度。我们希望提取出的特征无法被域分类器成功判别，以确认生成的特征是域无关的。</p>
<h2 id="AGW-2"><a href="#AGW-2" class="headerlink" title="AGW [2]"></a>AGW [2]</h2><p><img src="https://p.ipic.vip/uyfxkp.png" alt=""></p>
<p>考虑到表层特征差异大的问题，还尝试了通过分开卷积层的方法。首先使用域单独的卷积层提取出表层特征，再进入相同的Resnet+NoLocal块的网络，增加对全域特征的提取能力。</p>
<h2 id="HeadReID"><a href="#HeadReID" class="headerlink" title="HeadReID"></a>HeadReID</h2><p><img src="https://p.ipic.vip/yczuur.png" alt=""></p>
<p>根据文献 [3]，仅仅是头部特征也有惊人的表达能力。因此尝试了增加提取头部特征的网络，以抵御域变换带来的影响。</p>
<h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><p>主要为以下步骤：</p>
<ol>
<li>数据处理：视频转换为图片，根据真值切割出每一帧的正确的行人图片，为每个行人制作文件夹，形成最后的数据库<ul>
<li>对于HeadReID使用的头部图片由于没有真值，简单的利用原行人图片的上部20%进行提取。</li>
</ul>
</li>
<li><p><strong>DANN：</strong>两个域的行人图片集分别传入Resnet50，提取出特征向量。利用此特征向量分别进行：</p>
<ol>
<li>度量学习：Triplet Loss</li>
<li>标签预测：Person ID预测 → label loss</li>
<li><p>域预测：属于入口/出口 → domain loss → 梯度翻转 →  ${y(domain loss)}$</p>
<p>三个loss之和最小化</p>
<p><strong>AGW：</strong>两个域的行人图片集分别传入各自的特征提取层。最小化分类损失。</p>
<p><strong>HeadReID：</strong>行人图片集及其头部图片分别传入对应的特征提取网络。最小化分类损失。</p>
</li>
</ol>
</li>
<li><p>使用测试集，求出两两行人图片之间的特征类似度，得出结果。</p>
</li>
</ol>
<h1 id="参数选择"><a href="#参数选择" class="headerlink" title="参数选择"></a>参数选择</h1><p>根据实验，使用sin函数作为类似度函数，以及对于每个ID的行人使用所有图片的平均特征量时效果过最好。</p>
<h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><p>最终结果说明，AGW的手法在里面的效果最好。尤其在人多时造成特征不完全时带来的收益最大。但是当有明显的局部特征如帽子耳机等时，DANN对其的学习能力更强。</p>
<p><img src="https://p.ipic.vip/a7fo4y.png" alt=""></p>
<p><img src="https://p.ipic.vip/e2yeq7.png" alt=""></p>
<p><img src="https://p.ipic.vip/t1se4t.png" alt=""></p>
<p>HeadReID的失败原因：</p>
<ol>
<li>虽然头部特征在前手法中论证有用，但实际本数据集的分辨率远远低于文献使用的数据集。</li>
<li>因为没有使用头部识别网络而仅仅进行了剪裁操作，衣服等域有关的特征不可避免的被混入。</li>
<li>数据集中有儿童的存在：他们无法使用简单的剪裁操作生成头部图片。</li>
</ol>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] Y. Ganin and V. Lempitsky. Unsupervised domain adaptation by backpropa- gation. In ICML, Vol. 37, pp. 1180–1189, 2015.</p>
<p>[2] M. Ye, J. Shen, G. Lin, T. Xiang, L. Shao, and S. C. H. Hoi. Deep Learning for Person Re-identification: A Survey and Outlook. TPAMI, pp. 1–1, 2021. doi:10.1109/TPAMI.2021.3054775.</p>
<p>[3] Junliang Guo, Yanbing Xue, Jing Cai, Zan Gao, Guangping Xu, and Hua Zhang. A bus passenger re-identification dataset and a deep learning baseline using triplet embedding. Multimedia Tools and Applications, Vol. 80, No. 11, pp. 16425–16440, 2021.</p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>提示工程 | Prompt Engineering</title>
    <url>/2023/05/09/prompt-engineering/</url>
    <content><![CDATA[<p>课程：<a href="https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/">https://www.deeplearning.ai/short-courses/chatgpt-prompt-engineering-for-developers/</a></p>
<p>课程代码：<a href="https://github.com/ArslanKAS/Prompt-Engineering-by-OpenAI">https://github.com/ArslanKAS/Prompt-Engineering-by-OpenAI</a></p>
<p>文档：<a href="https://platform.openai.com/docs/api-reference/introduction">https://platform.openai.com/docs/api-reference/introduction</a></p>
<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><ol>
<li>clear not equal short。有时必要的增加prompt的长度能下达更精准的命令。</li>
<li>使用区分符号如三引号，tag符号等。避免对模型产生误导。</li>
<li>解决复杂问题时要引导模型step by step的解决问题。模型有跳过说明性文字而直接看结果的倾向，可能导致错误答案。</li>
<li>要给模型思考时间。如提示他直到计算出答案前不要决定结果。</li>
<li>避免让模型直接生成名字等。模型有生成不存在的答案的倾向。必要时可以向模型提供相关的情报信息引导它生成真实存在的名字。</li>
<li>提示工程和深度学习的过程一样，是递归的。我们应该根据具体问题具体分析，在一次次的实验中找到最优prompt。</li>
<li>巧妙利用数组存放prompts，以让模型进行流水线工作。</li>
<li>对结果的格式进行要求以获得适合编程用的内容：转化JSON，作成html形式，数值化等。</li>
</ol>
<h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><h3 id="openai-的api导入："><a href="#openai-的api导入：" class="headerlink" title="openai 的api导入："></a>openai 的api导入：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> openai</span><br><span class="line">openai.api_key = os.getenv(<span class="string">&quot;OPENAI_API_KEY&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="传回结果："><a href="#传回结果：" class="headerlink" title="传回结果："></a>传回结果：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_completion</span>(<span class="params">prompt, model=<span class="string">&quot;gpt-3.5-turbo&quot;</span></span>):</span><br><span class="line">    messages = [&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: prompt&#125;]</span><br><span class="line">    response = openai.ChatCompletion.create(</span><br><span class="line">        model=model,</span><br><span class="line">        messages=messages,</span><br><span class="line">        temperature=<span class="number">0</span>, <span class="comment"># this is the degree of randomness of the model&#x27;s output</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> response.choices[<span class="number">0</span>].message[<span class="string">&quot;content&quot;</span>]</span><br></pre></td></tr></table></figure>
<h2 id="方法一：处理多任务并生成具体格式的回答"><a href="#方法一：处理多任务并生成具体格式的回答" class="headerlink" title="方法一：处理多任务并生成具体格式的回答"></a>方法一：处理多任务并生成具体格式的回答</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;&quot;&quot;...&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">prompt_2 = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">你的任务如下：</span></span><br><span class="line"><span class="string">1. 总结&lt;&gt;内包含的内容为一句话</span></span><br><span class="line"><span class="string">2. 将总结的内容转换为法语</span></span><br><span class="line"><span class="string">3. 将法语总结里的名字列成表</span></span><br><span class="line"><span class="string">4. 生成json对象，里面应包含以下的键：法语总结，名字</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">答案应使用如下的格式：</span></span><br><span class="line"><span class="string">Text: &lt;text to summarize&gt;</span></span><br><span class="line"><span class="string">Summary: &lt;summary&gt;</span></span><br><span class="line"><span class="string">Translation: &lt;summary translation&gt;</span></span><br><span class="line"><span class="string">Names: &lt;list of names in Italian summary&gt;</span></span><br><span class="line"><span class="string">Output JSON: &lt;json with summary and num_names&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">文本如下</span></span><br><span class="line"><span class="string">Text: &lt;<span class="subst">&#123;text&#125;</span>&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">response = get_completion(prompt_2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nCompletion for prompt 2:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure>
<h2 id="方法二：引导step-by-step的生成答案-给模型思考时间"><a href="#方法二：引导step-by-step的生成答案-给模型思考时间" class="headerlink" title="方法二：引导step by step的生成答案 | 给模型思考时间"></a>方法二：引导step by step的生成答案 | 给模型思考时间</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Your task is to determine if the student&#x27;s solution \</span></span><br><span class="line"><span class="string">is correct or not.</span></span><br><span class="line"><span class="string">To solve the problem do the following:</span></span><br><span class="line"><span class="string">- First, work out your own solution to the problem. </span></span><br><span class="line"><span class="string">- Then compare your solution to the student&#x27;s solution \ </span></span><br><span class="line"><span class="string">and evaluate if the student&#x27;s solution is correct or not. </span></span><br><span class="line"><span class="string">Don&#x27;t decide if the student&#x27;s solution is correct until </span></span><br><span class="line"><span class="string">you have done the problem yourself.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Use the following format:</span></span><br><span class="line"><span class="string">Question:</span></span><br><span class="line"><span class="string">\```</span></span><br><span class="line"><span class="string">question here</span></span><br><span class="line"><span class="string">\```</span></span><br><span class="line"><span class="string">Student&#x27;s solution:</span></span><br><span class="line"><span class="string">\```</span></span><br><span class="line"><span class="string">student&#x27;s solution here</span></span><br><span class="line"><span class="string">\```</span></span><br><span class="line"><span class="string">Actual solution:</span></span><br><span class="line"><span class="string">\```</span></span><br><span class="line"><span class="string">steps to work out the solution and your solution here</span></span><br><span class="line"><span class="string">\```</span></span><br><span class="line"><span class="string">Is the student&#x27;s solution the same as actual solution \</span></span><br><span class="line"><span class="string">just calculated:</span></span><br><span class="line"><span class="string">\```</span></span><br><span class="line"><span class="string">yes or no</span></span><br><span class="line"><span class="string">\```</span></span><br><span class="line"><span class="string">Student grade:</span></span><br><span class="line"><span class="string">\```</span></span><br><span class="line"><span class="string">correct or incorrect</span></span><br><span class="line"><span class="string">\```</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Question:</span></span><br><span class="line"><span class="string">\```</span></span><br><span class="line"><span class="string">I&#x27;m building a solar power installation and I need help \</span></span><br><span class="line"><span class="string">working out the financials. </span></span><br><span class="line"><span class="string">- Land costs $100 / square foot</span></span><br><span class="line"><span class="string">- I can buy solar panels for $250 / square foot</span></span><br><span class="line"><span class="string">- I negotiated a contract for maintenance that will cost \</span></span><br><span class="line"><span class="string">me a flat $100k per year, and an additional $10 / square \</span></span><br><span class="line"><span class="string">foot</span></span><br><span class="line"><span class="string">What is the total cost for the first year of operations \</span></span><br><span class="line"><span class="string">as a function of the number of square feet.</span></span><br><span class="line"><span class="string">\```</span></span><br><span class="line"><span class="string">Student&#x27;s solution:</span></span><br><span class="line"><span class="string">\```</span></span><br><span class="line"><span class="string">Let x be the size of the installation in square feet.</span></span><br><span class="line"><span class="string">Costs:</span></span><br><span class="line"><span class="string">1. Land cost: 100x</span></span><br><span class="line"><span class="string">2. Solar panel cost: 250x</span></span><br><span class="line"><span class="string">3. Maintenance cost: 100,000 + 100x</span></span><br><span class="line"><span class="string">Total cost: 100x + 250x + 100,000 + 100x = 450x + 100,000</span></span><br><span class="line"><span class="string">\```</span></span><br><span class="line"><span class="string">Actual solution:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">response = get_completion(prompt)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure>
<h2 id="方法三：给模型足够的情报"><a href="#方法三：给模型足够的情报" class="headerlink" title="方法三：给模型足够的情报"></a>方法三：给模型足够的情报</h2><blockquote>
<p>这个prompt非常长，但是给了模型非常多的需要的信息以生成想要的答案：模型担任的职能，需要关注的细节，面向的客户群体，必须输出的内容。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Your task is to help a marketing team create a </span></span><br><span class="line"><span class="string">description for a retail website of a product based </span></span><br><span class="line"><span class="string">on a technical fact sheet.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Write a product description based on the information </span></span><br><span class="line"><span class="string">provided in the technical specifications delimited by </span></span><br><span class="line"><span class="string">triple backticks.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The description is intended for furniture retailers, </span></span><br><span class="line"><span class="string">so should be technical in nature and focus on the </span></span><br><span class="line"><span class="string">materials the product is constructed from.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">At the end of the description, include every 7-character </span></span><br><span class="line"><span class="string">Product ID in the technical specification.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Use at most 50 words.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Technical specifications: ```<span class="subst">&#123;fact_sheet_chair&#125;</span>```</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">response = get_completion(prompt)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure>
<h2 id="方法四：处理流水线"><a href="#方法四：处理流水线" class="headerlink" title="方法四：处理流水线"></a>方法四：处理流水线</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(reviews)):</span><br><span class="line">    prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Your task is to generate a short summary of a product \ </span></span><br><span class="line"><span class="string">    review from an ecommerce site. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Summarize the review below, delimited by triple \</span></span><br><span class="line"><span class="string">    backticks in at most 20 words. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Review: ```<span class="subst">&#123;reviews[i]&#125;</span>```</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    response = get_completion(prompt)</span><br><span class="line">    <span class="built_in">print</span>(i, response, <span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="场景一：对客户评价进行处理并提供可分析的数据"><a href="#场景一：对客户评价进行处理并提供可分析的数据" class="headerlink" title="场景一：对客户评价进行处理并提供可分析的数据"></a>场景一：对客户评价进行处理并提供可分析的数据</h2><blockquote>
<p>利用模型自动对客户的满意度进行评价。利用此我们还可以想到更多的可能性：</p>
<ol>
<li>预警系统。对不满意的客户及时预警和对应。</li>
<li>分析系统。每个产品的满意程度的分析。</li>
<li>处理系统。对不满意的客户我们可以利用提取到的关键信息，让模型先自动进行消息回复的对应。并且可以通过更改temp参数增加其多样性。</li>
<li>流水线处理。利用数组就可以批量处理。</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prompt = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Identify the following items from the review text: </span></span><br><span class="line"><span class="string">- Sentiment (positive or negative)</span></span><br><span class="line"><span class="string">- Is the reviewer expressing anger? (true or false)</span></span><br><span class="line"><span class="string">- Item purchased by reviewer</span></span><br><span class="line"><span class="string">- Company that made the item</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">The review is delimited with triple backticks. \</span></span><br><span class="line"><span class="string">Format your response as a JSON object with \</span></span><br><span class="line"><span class="string">&quot;Sentiment&quot;, &quot;Anger&quot;, &quot;Item&quot; and &quot;Brand&quot; as the keys.</span></span><br><span class="line"><span class="string">If the information isn&#x27;t present, use &quot;unknown&quot; \</span></span><br><span class="line"><span class="string">as the value.</span></span><br><span class="line"><span class="string">Make your response as short as possible.</span></span><br><span class="line"><span class="string">Format the Anger value as a boolean.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Review text: &#x27;&#x27;&#x27;<span class="subst">&#123;lamp_review&#125;</span>&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">response = get_completion(prompt)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure>
<h2 id="场景二：对话机器人"><a href="#场景二：对话机器人" class="headerlink" title="场景二：对话机器人"></a>场景二：对话机器人</h2><p>可对话型和上述的单纯处理型的区别在于：需要记忆能力。</p>
<p>因此首先我们使用新的函数。其中messages里记录了前面的对话。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_completion_from_messages</span>(<span class="params">messages, model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>, temperature=<span class="number">0</span></span>):</span><br><span class="line">    response = openai.ChatCompletion.create(</span><br><span class="line">        model=model,</span><br><span class="line">        messages=messages,</span><br><span class="line">        temperature=temperature, <span class="comment"># this is the degree of randomness of the model&#x27;s output</span></span><br><span class="line">    )</span><br><span class="line"><span class="comment">#     print(str(response.choices[0].message))</span></span><br><span class="line">    <span class="keyword">return</span> response.choices[<span class="number">0</span>].message[<span class="string">&quot;content&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>message的格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">messages =  [  </span><br><span class="line">&#123;<span class="string">&#x27;role&#x27;</span>:<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;content&#x27;</span>:<span class="string">&#x27;You are an assistant that speaks like Shakespeare.&#x27;</span>&#125;,    </span><br><span class="line">&#123;<span class="string">&#x27;role&#x27;</span>:<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;content&#x27;</span>:<span class="string">&#x27;tell me a joke&#x27;</span>&#125;,   </span><br><span class="line">&#123;<span class="string">&#x27;role&#x27;</span>:<span class="string">&#x27;assistant&#x27;</span>, <span class="string">&#x27;content&#x27;</span>:<span class="string">&#x27;Why did the chicken cross the road&#x27;</span>&#125;,   </span><br><span class="line">&#123;<span class="string">&#x27;role&#x27;</span>:<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;content&#x27;</span>:<span class="string">&#x27;I don\&#x27;t know&#x27;</span>&#125;  ]</span><br></pre></td></tr></table></figure>
<p>system为最高层的要求，相当于下达prompt的系统。user为客户，assistant为模型。</p>
<p>接下来利用GUI包生成披萨订购助手：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 储存之前的对话</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">collect_messages</span>(<span class="params">_</span>):</span><br><span class="line">    prompt = inp.value_input</span><br><span class="line">    inp.value = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    context.append(&#123;<span class="string">&#x27;role&#x27;</span>:<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;content&#x27;</span>:<span class="string">f&quot;<span class="subst">&#123;prompt&#125;</span>&quot;</span>&#125;)</span><br><span class="line">    response = get_completion_from_messages(context) </span><br><span class="line">    context.append(&#123;<span class="string">&#x27;role&#x27;</span>:<span class="string">&#x27;assistant&#x27;</span>, <span class="string">&#x27;content&#x27;</span>:<span class="string">f&quot;<span class="subst">&#123;response&#125;</span>&quot;</span>&#125;)</span><br><span class="line">    panels.append(</span><br><span class="line">        pn.Row(<span class="string">&#x27;User:&#x27;</span>, pn.pane.Markdown(prompt, width=<span class="number">600</span>)))</span><br><span class="line">    panels.append(</span><br><span class="line">        pn.Row(<span class="string">&#x27;Assistant:&#x27;</span>, pn.pane.Markdown(response, width=<span class="number">600</span>, style=&#123;<span class="string">&#x27;background-color&#x27;</span>: <span class="string">&#x27;#F6F6F6&#x27;</span>&#125;)))</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> pn.Column(*panels)</span><br><span class="line"></span><br><span class="line"><span class="comment">##MAIN</span></span><br><span class="line"><span class="keyword">import</span> panel <span class="keyword">as</span> pn  <span class="comment"># GUI</span></span><br><span class="line">pn.extension()</span><br><span class="line"></span><br><span class="line">panels = [] <span class="comment"># collect display </span></span><br><span class="line"></span><br><span class="line">context = [ &#123;<span class="string">&#x27;role&#x27;</span>:<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;content&#x27;</span>:<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">You are OrderBot, an automated service to collect orders for a pizza restaurant. \</span></span><br><span class="line"><span class="string">You first greet the customer, then collects the order, \</span></span><br><span class="line"><span class="string">and then asks if it&#x27;s a pickup or delivery. \</span></span><br><span class="line"><span class="string">You wait to collect the entire order, then summarize it and check for a final \</span></span><br><span class="line"><span class="string">time if the customer wants to add anything else. \</span></span><br><span class="line"><span class="string">If it&#x27;s a delivery, you ask for an address. \</span></span><br><span class="line"><span class="string">Finally you collect the payment.\</span></span><br><span class="line"><span class="string">Make sure to clarify all options, extras and sizes to uniquely \</span></span><br><span class="line"><span class="string">identify the item from the menu.\</span></span><br><span class="line"><span class="string">You respond in a short, very conversational friendly style. \</span></span><br><span class="line"><span class="string">The menu includes \</span></span><br><span class="line"><span class="string">pepperoni pizza  12.95, 10.00, 7.00 \</span></span><br><span class="line"><span class="string">cheese pizza   10.95, 9.25, 6.50 \</span></span><br><span class="line"><span class="string">eggplant pizza   11.95, 9.75, 6.75 \</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>&#125; ]  <span class="comment"># accumulate messages</span></span><br><span class="line"></span><br><span class="line">inp = pn.widgets.TextInput(value=<span class="string">&quot;Hi&quot;</span>, placeholder=<span class="string">&#x27;Enter text here…&#x27;</span>)</span><br><span class="line">button_conversation = pn.widgets.Button(name=<span class="string">&quot;Chat!&quot;</span>)</span><br><span class="line"></span><br><span class="line">interactive_conversation = pn.bind(collect_messages, button_conversation)</span><br><span class="line"></span><br><span class="line">dashboard = pn.Column(</span><br><span class="line">    inp,</span><br><span class="line">    pn.Row(button_conversation),</span><br><span class="line">    pn.panel(interactive_conversation, loading_indicator=<span class="literal">True</span>, height=<span class="number">300</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">dashboard</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title>【花书】从概率统计到深度网络的概率预测</title>
    <url>/2023/01/05/probability-output/</url>
    <content><![CDATA[<p>参考深度学习花书</p>
<p>第三章 概率与信息论【常用统计量，分布】</p>
<p>第五章 机器学习基础【参数选择，最大似然估计】</p>
<p>第六章 深度前馈网络【输出单元】</p>
<h2 id="概率统计"><a href="#概率统计" class="headerlink" title="概率统计"></a>概率统计</h2><h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>离散: $E[f(x)]=\sum_xP(x)f(x)$</p>
<p>连续： $E[f(x)]=\int P(x)f(x)dx$</p>
<p>默认地，我们假设E表示对括号内的所有随机变量求平均</p>
<p>性质：线性</p>
<script type="math/tex; mode=display">E(af(x)+bg(x)+c)=aE(f(x))+bE(g(x))+c</script><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><p>对x依照概率分布采样时，随机变量x的函数值会呈现多大的差异</p>
<p>离散： <script type="math/tex">Var(f(x))=E[(f(x)-E[f(x)])^2]</script></p>
<h3 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h3><p>两个变量线性相关性的强度以及这些变量的尺度</p>
<script type="math/tex; mode=display">Cov(f(x),g(y))=E[(f(x)-E[f(x)])(g(y)-E[g(y)])]</script><p>随机变量组成的向量之间可构成协方差矩阵，其对角元素为方差</p>
<script type="math/tex; mode=display">Cov(x)_{i,j}=Cov(x_i, x_j)</script><ul>
<li>变量的尺度：1. 绝对值越大，变化越大 2. 若为正，则两个变量都倾向于取较于均值更大的值</li>
<li>相关性：若为0，则无线性相关；若不为0，则一定相关</li>
<li>注意：相关性比独立性的要求更弱。相关性无法判断非线性相关性，而独立性要求线性非线性均无关。</li>
</ul>
<h3 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h3><p>将协方差变量进行归一化，达到之衡量变量的相关性而不受各个变量尺度大小的影响。</p>
<script type="math/tex; mode=display">Cov(f(x),g(y))=\frac{E[(f(x)-E[f(x)])(g(y)-E[g(y)])]}{\sqrt{Var(f(x))Var(g(y))}}</script><h2 id="常见分布"><a href="#常见分布" class="headerlink" title="常见分布"></a>常见分布</h2><h3 id="伯努利分布"><a href="#伯努利分布" class="headerlink" title="伯努利分布"></a>伯努利分布</h3><p>单个二值随机变量的分布。展示了只有两种可能性（0或1）的事件，分别发生的概率x的分布。必然发生的概率为 $\phi$。常用于深度学习的二分类问题。</p>
<script type="math/tex; mode=display">P(x=1)=\phi</script><script type="math/tex; mode=display">P(x=0)=1-\phi</script><p>将两个式子合二为一：（注意：这个式子只是一种简化写法，并不代表x能取任意值。实际上它只能取{0,1}）</p>
<script type="math/tex; mode=display">P(\text{x}=x)=\phi^x(1-\phi)^{1-x}</script><p>其期望和方差：</p>
<script type="math/tex; mode=display">E(x)=\phi</script><script type="math/tex; mode=display">Var(x)=\phi(1-\phi)</script><h3 id="n重伯努利分布"><a href="#n重伯努利分布" class="headerlink" title="n重伯努利分布"></a>n重伯努利分布</h3><p>具有k个不同状态的单个离散型随机变量上的分布。由向量 $p\in\{0,1\}^{k}$ (k个二值元素)参数化。其中每一个分量 $p_i$表示第 $i$个状态的概率。</p>
<p><strong>伯努利分布并不是特别强大， 但是它们的领域足够简单。它们可以对那些能够将所有的状态进行枚举的离散型随机变量进行建模。</strong></p>
<h3 id="高斯分布（正态分布）"><a href="#高斯分布（正态分布）" class="headerlink" title="高斯分布（正态分布）"></a>高斯分布（正态分布）</h3><p>实数上最常用的分布。由参数 $\mu$和 $\sigma$控制。</p>
<script type="math/tex; mode=display">\mathcal N(x;\mu,\sigma^2)=\sqrt{\frac{1}{2\pi \sigma^2}}\text{exp}(-\frac{1}{2\sigma^2}(x-\mu)^2)</script><p>另一种方式是使用 $\beta=1/\sigma^2$来控制分布的精度。写作：</p>
<script type="math/tex; mode=display">\mathcal N(x;\mu,\beta^{-1})=\sqrt{\frac{\beta}{2\pi}}\text{exp}(-\frac{1}{2\sigma^2}(x-\mu)^2)</script><p>推广到高维空间的多维正态分布。 $\mu$变为向量表示的均值， $\Sigma$为协方差矩阵（一般写作对角阵即只有方差足矣）</p>
<script type="math/tex; mode=display">\mathcal N(x;\mu,\Sigma)=\sqrt{\frac{1}{(2\pi)^n\text{det}(\Sigma)}}\text{exp}(-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu))</script><script type="math/tex; mode=display">\mathcal N(x;\mu,\beta^{-1})=\sqrt{\frac{\text{det}(\beta)}{(2\pi)^n}}\text{exp}(-\frac{1}{2}(x-\mu)^T\beta(x-\mu))</script><p>高斯分布具有以下优点：</p>
<ol>
<li>许多真实事件的分布接近于高斯分布。（中心极限定理）</li>
<li>在相同方差的所有概率分布中，高斯分布具有最大不确定性。因此所需要的先验知识量更少。（少量的训练数据可获得更大的学习收益）</li>
</ol>
<p>因此正态分布是我们缺乏先验知识时最好的默认选择。</p>
<h3 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h3><p>x=0周围的边界点的分布。</p>
<ul>
<li>$\lambda e^{-\lambda x}$     $x \geq 0$</li>
<li>0              $x &lt; 0$</li>
</ul>
<h2 id="点估计：参数选择与验证"><a href="#点估计：参数选择与验证" class="headerlink" title="点估计：参数选择与验证"></a>点估计：参数选择与验证</h2><p>点估计试图为一些感兴趣的参数提供单个最优预测。对于 独立同分布的 $\{x^1, x^2…,x^m\}$，点估计或统计量是这些数据的任意函数：</p>
<script type="math/tex; mode=display">\hat \theta_m = g(x^1...x^m)</script><p>防止误解，我们一般将真实的参数值写作 $\theta$， 将预测值写作 $\hat \theta$ </p>
<p>为了衡量预测的点估计的特点，我们一般通过如下性质进行判断</p>
<ul>
<li><p>偏差：度量偏离真实参数的误差期望</p>
<script type="math/tex; mode=display">bias(\hat \theta_m)=E(\hat \theta_m)-\theta</script></li>
<li><p>方差：度量数据上任意特定采样可能导致的估计期望的偏差</p>
<script type="math/tex; mode=display">Var(\hat \theta)</script></li>
<li><p>一致性：估计量的偏离度应随着数据样本的增加而减少</p>
<script type="math/tex; mode=display">\text{plim}_{m\rightarrow \infty}\hat \theta_m = \theta</script></li>
</ul>
<h3 id="过拟合与欠拟合"><a href="#过拟合与欠拟合" class="headerlink" title="过拟合与欠拟合"></a>过拟合与欠拟合</h3><p>可以看到，两个性质分别对应着参数的不同性质。理想中我们希望两个性质都能最优。实际上，随着模型容量（模型的大小，学习能力）的增大，偏差会降低，方差却会增大，从而进入过拟合的阶段。如何权衡两个值找到最优的模型容量成为重要问题。</p>
<p><img src="https://p.ipic.vip/a004t8.png" alt=""></p>
<h3 id="最优模型寻找对策：均方误差与交叉验证"><a href="#最优模型寻找对策：均方误差与交叉验证" class="headerlink" title="最优模型寻找对策：均方误差与交叉验证"></a>最优模型寻找对策：均方误差与交叉验证</h3><p>均方误差度量着估计和真实参数间平方误差的总体期望。他同时包含了偏差和方差。因此理想的点估计应该具有较小的MSE。</p>
<script type="math/tex; mode=display">\text{MSE}=E[(\hat \theta_m-\theta)^2]=Bias(\hat \theta_m)^2+Var(\hat \theta_m)</script><blockquote>
<p>还有一种常见的方法是使用交叉验证对不同模型进行正确评估。最后选择误差最小的模型。</p>
</blockquote>
<h2 id="最大似然估计：参数估计"><a href="#最大似然估计：参数估计" class="headerlink" title="最大似然估计：参数估计"></a>最大似然估计：参数估计</h2><p>上面讲述了对于得到的参数，如何评判其好坏。本节的最大似然估计则告诉我们如何进行通过数据学习合理的参数。</p>
<p>对参数 $\theta$的最大似然估计为：</p>
<p>（其中 $p_{model}$是模型从数据学到的概率，以估计真实概率 $p_{data}$。真实概率代表了x出现的概率。）</p>
<script type="math/tex; mode=display">\theta_{ML}=argmax_{\theta}p_{model}(X,\theta)=argmax_{\theta}\prod^{m}_{i=1} p_{model}(x^i,\theta)=argmax_{\theta}\sum^{m}_{i=1}\log p_{model}=(x^i,\theta)=argmax_{\theta}E_{p\sim \hat p_{data}}\log p_{model}(x^i,\theta)</script><p> 不难理解，第一个式子代表了当估计参数能使训练数据x出现概率最大的时候，我们选其为最优参数。之后根据联合概率，log函数的性质，argmax的缩放不变性，变成了最后的式子的样子（为什么是x遵循经验分布下的期望值？因为我们不知道真实分布哇，只能曲线救国咯）。</p>
<p>另一种观点是把最大似然估计看做经验分布和模型分布之间的差异，用KL散度表示（其实也就是交叉熵）：</p>
<script type="math/tex; mode=display">$D_{KL}(\hat p_{data}||p_{mdoel})=E_{x\sim \hat p_{data}}[\log \hat p_{data}(x)-\log p_{model}(x)]</script><p> 数据相关的统计量我们管不着，因此其实最大似然只和右边的值有关系。</p>
<script type="math/tex; mode=display">\theta_{ML}=argmax_{\theta}E_{p\sim \hat p_{data}}\log p_{model}(x^i,\theta)=-E_{x\sim \hat p_{data}}\log p_{model}(x)</script><p> 列了一堆式子，最终只要记住上面这一行就够了。所以参数选择中最小化KL散度其实就是等同于最大化似然。</p>
<p>最后，这里的似然估计是对于模拟分布场景的。对于(x,y)类型的监督学习，应该写作：（也就是当数据分布遵循经验分布时，x生成真实值y的概率应该最大）</p>
<script type="math/tex; mode=display">\theta_{ML}=-E_{x,y\sim \hat p_{data}}\log p_{model}(y|x)</script><h2 id="输出单元"><a href="#输出单元" class="headerlink" title="输出单元"></a>输出单元</h2><p>最后一个问题来了：我们知道了参数如何进行估计，但是最基本的模型分布到底要怎么表示？如何通过数据建模模型分布？这个就涉及到了网络输出层的函数设计：如何使用正确的函数代表 $p_{model}$。</p>
<p>由于网络的任务基本为回归，二分类，多分类。因此只讨论这三种情况下的输出单元。当然，大多数输出单元也可被用于隐藏层。</p>
<p>假设现在神经网络为输出层提供了一组为 $h$的隐藏特征。</p>
<h3 id="线性单元"><a href="#线性单元" class="headerlink" title="线性单元"></a>线性单元</h3><p>基于仿射变换。此时假设该线性回归应遵循正态分布。</p>
<script type="math/tex; mode=display">\hat y=W^Th+b</script><script type="math/tex; mode=display">P(y|x)=\mathcal N (y;\hat y,I)</script><h3 id="sigmoid单元"><a href="#sigmoid单元" class="headerlink" title="sigmoid单元"></a>sigmoid单元</h3><p>基于伯努利分布，适用于二分类问题。</p>
<script type="math/tex; mode=display">\sigma(x)=\frac{1}{1+\exp(-x)}</script><p>伯努利函数要求变量出现概率应小于1而大于0。sigmoid的性质完美符合了它：</p>
<p><img src="https://p.ipic.vip/gc31e7.png" alt=""></p>
<script type="math/tex; mode=display">\sigma(x)=\frac{\exp(x)}{\exp(x)+\exp(0)}</script><script type="math/tex; mode=display">\sigma'(x)=\sigma(x)(1-\sigma(x))</script><script type="math/tex; mode=display">\sigma(-x)=1-\sigma(x)</script><blockquote>
<p>当输入值绝对值较大时，很明显sigmoid的函数将会饱和（很平），这不利于我们计算梯度（非常小）。但是还好，负对数似然会帮我们中和。</p>
</blockquote>
<h3 id="softmax单元"><a href="#softmax单元" class="headerlink" title="softmax单元"></a>softmax单元</h3><p>基于n重伯努利分布，适用于多分类问题。不仅仅每一个的概率在[0,1]范围内，甚至所有事件的总概率应该是等于1的：</p>
<script type="math/tex; mode=display">z = W^Th+b</script><script type="math/tex; mode=display">\text{softmax}(z)_i=\frac{\exp(z_i)}{\sum_j{\exp(z_j)}}</script><p>首先线性层进行对数概率的预测，之后再对z进行指数化和归一化（TODO）</p>
<blockquote>
<p>太困了，有点匆忙，有空最后再补吧</p>
</blockquote>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title>Queue Theory</title>
    <url>/2022/06/05/queue-theory/</url>
    <content><![CDATA[<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>对于某个服务大厅，已知（1）单位时间内会来的客人数（2）服务客人需要的平均时间</p>
<ul>
<li>下一个客人什么时候来？（=t时间内来客人的概率为？）</li>
<li>t时间后，队伍会排多长？</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li>客人到达</li>
<li>排队</li>
<li>窗口服务</li>
<li>离开</li>
</ul>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>两个重要初始化概念：1. 客人到达时间的概率分布 2. 服务时长的概率分布<br>这两个定下来后排队所需时间和客人离开时间就固定下来了</p>
<ul>
<li>M/M/1：到达时间和服务时长满足泊松分布，且只有一个服务窗口</li>
<li>M/D/1：到达时间满足泊松分布，服务时长满足固定分布，且只有一个服务窗口</li>
</ul>
<h2 id="泊松分布（负指数分布）"><a href="#泊松分布（负指数分布）" class="headerlink" title="泊松分布（负指数分布）"></a>泊松分布（负指数分布）</h2><p>性质</p>
<ul>
<li>无记忆性（马尔科夫模型）</li>
</ul>
<p>泊松分布就是描述某段时间内，事件具体的发生概率。<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2x5941bvnj20oc04waa0.jpg" alt=""></p>
<ul>
<li>P：概率 </li>
<li>N： 某种函数关系，</li>
<li>t：时间</li>
<li>n：数量，1小时内出生3个婴儿的概率，就表示为 P(N(1) = 3) 。</li>
<li>λ：表示事件的平均频率（如已知一小时内平均畜生5个婴儿则λ=5）</li>
</ul>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% M/M/1 シミュレーション</span></span><br><span class="line"><span class="comment">% イベント駆動型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%シミュレーションの時間</span></span><br><span class="line">T = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%客数</span></span><br><span class="line">N = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 客の構造体の定義と初期化</span></span><br><span class="line">s.arrivalTime_ = <span class="number">-1</span>;</span><br><span class="line">s.departureTime_ = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% repmatは配列のコピーをするコマンド</span></span><br><span class="line"><span class="comment">% repmat(s, N, 1) により，sの値を持つＮ×1行列ができる</span></span><br><span class="line"><span class="comment">% 存储客人的到达时间和离开时间S(N*2)</span></span><br><span class="line">S = <span class="built_in">repmat</span>(s, N, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 乱数</span></span><br><span class="line">[rndArrival, rndDeparture] = RandStream.create(<span class="string">&#x27;mrg32k3a&#x27;</span>,<span class="string">&#x27;NumStreams&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;seed&#x27;</span>,seed);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 最初の到着時刻</span></span><br><span class="line">numArrivals = <span class="number">0</span>;</span><br><span class="line">curTime = expRandom(rndArrival, lambda);</span><br><span class="line"></span><br><span class="line">nextEvent = <span class="string">&#x27;arrival&#x27;</span>;</span><br><span class="line">nextArrivalTime = T;</span><br><span class="line">nextDepartureTime = T;</span><br><span class="line"></span><br><span class="line">numDepartures = <span class="number">0</span>;</span><br><span class="line">queueLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%出力用</span></span><br><span class="line">queueTrace = <span class="built_in">zeros</span>(N, <span class="number">2</span>);</span><br><span class="line">qnum = <span class="number">0</span>;</span><br><span class="line">numEvent = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(curTime &lt; T &amp;&amp; numArrivals &lt;= N)</span><br><span class="line">    </span><br><span class="line">    numEvent = numEvent + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(strcmp(nextEvent, <span class="string">&#x27;arrival&#x27;</span>))</span><br><span class="line">        <span class="comment">%到着時のキュー長の累積値を増やす</span></span><br><span class="line">        qnum = qnum + queueLength;</span><br><span class="line">        <span class="comment">%到着した客数の累積値を一つ増やす</span></span><br><span class="line">        numArrivals = numArrivals + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">%客の到着時刻を構造体に記録</span></span><br><span class="line">        S(numArrivals, <span class="number">1</span>).arrivalTime_ = curTime;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%空のキューに到着した客ならば出発時刻を決める</span></span><br><span class="line">        <span class="keyword">if</span>(queueLength == <span class="number">0</span>)</span><br><span class="line">        	<span class="comment">% 如果需要M/D/1模型就把这个expRandom()改成加常数</span></span><br><span class="line">            nextDepartureTime = curTime + expRandom(rndDeparture, mu);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">%キュー長を1つ増加</span></span><br><span class="line">        queueLength = queueLength + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">%次の到着時刻を決める</span></span><br><span class="line">        nextArrivalTime = curTime + expRandom(rndArrival, lambda);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">elseif</span>(strcmp(nextEvent, <span class="string">&#x27;departure&#x27;</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%出発した客数の累積値を増加</span></span><br><span class="line">        numDepartures = numDepartures + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">%出発時刻を構造体に記録</span></span><br><span class="line">        S(numDepartures, <span class="number">1</span>).departureTime_ = curTime;</span><br><span class="line">        <span class="comment">%キュー長を一つ減らす</span></span><br><span class="line">        queueLength = queueLength - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%キュー長が正ならば次の出発時刻を決める</span></span><br><span class="line">        <span class="keyword">if</span>(queueLength &gt; <span class="number">0</span>)</span><br><span class="line">            nextDepartureTime = curTime + expRandom(rndDeparture, mu);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">%キュー長が0ならばシミュレーション終了時刻を出発時刻とする</span></span><br><span class="line">            nextDepartureTime = T;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    queueTrace(numEvent, <span class="number">1</span>) = curTime;</span><br><span class="line">    queueTrace(numEvent, <span class="number">2</span>) = queueLength;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(nextArrivalTime &lt;= nextDepartureTime)</span><br><span class="line">        nextEvent = <span class="string">&#x27;arrival&#x27;</span>;</span><br><span class="line">        curTime = nextArrivalTime;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        nextEvent = <span class="string">&#x27;departure&#x27;</span>;</span><br><span class="line">        curTime = nextDepartureTime;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sumQueue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: numEvent - <span class="number">1</span></span><br><span class="line">    sumQueue = sumQueue + (queueTrace(<span class="built_in">i</span> + <span class="number">1</span>, <span class="number">1</span>) - queueTrace(<span class="built_in">i</span>, <span class="number">1</span>)) * queueTrace(<span class="built_in">i</span>, <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">totalTime = queueTrace(numEvent, <span class="number">1</span>) - queueTrace(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">timeAvgQueue = sumQueue/totalTime;</span><br><span class="line">avgQueue = qnum/numArrivals;</span><br><span class="line"></span><br><span class="line">delays = <span class="built_in">zeros</span>(numDepartures,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: numDepartures</span><br><span class="line">    delays(<span class="built_in">i</span>, <span class="number">1</span>) = S(<span class="built_in">i</span>).departureTime_ - S(<span class="built_in">i</span>).arrivalTime_;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="关于平均值的t检定"><a href="#关于平均值的t检定" class="headerlink" title="关于平均值的t检定"></a>关于平均值的t检定</h2><ul>
<li>两个样本的母分散不同时的t检定<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h2x5hs8q8jj20ie0jtaby.jpg" alt=""></li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>OR</tag>
      </tags>
  </entry>
  <entry>
    <title>【强化学习】chatGPT的工作原理</title>
    <url>/2022/12/31/what-is-chatgpt/</url>
    <content><![CDATA[<p><strong>内容参考</strong>：</p>
<p>[1] How ChatGPT actually works : <a href="https://www.assemblyai.com/blog/how-chatgpt-actually-works/?continueFlag=49271bb2584143248da2304817eb2d87">https://www.assemblyai.com/blog/how-chatgpt-actually-works/?continueFlag=49271bb2584143248da2304817eb2d87</a></p>
<p>[2] 强化学习一基础部分 : <a href="https://zhuanlan.zhihu.com/p/555303537">https://zhuanlan.zhihu.com/p/555303537</a></p>
<h2 id="术语说明"><a href="#术语说明" class="headerlink" title="术语说明"></a>术语说明</h2><ul>
<li>Capability（能力）</li>
<li>Allignment（对齐性/泛化性）</li>
</ul>
<p><img src="https://p.ipic.vip/4yng5g.jpg" alt=""></p>
<h2 id="传统语言模型的缺陷"><a href="#传统语言模型的缺陷" class="headerlink" title="传统语言模型的缺陷"></a>传统语言模型的缺陷</h2><p>现在流行的语言模型训练方式有<code>Next-token-prediction</code> （下文预测）和 <code>masked-language-modeling</code> （遮挡预测）， 如大名鼎鼎的transformer。这种方式使得模型能够学习完美构成的语句，却无法真正理解更高级别的语义内容。其特点是能力高，泛化度低。比起人类的复杂的判断系统（语境，常识等），语言模型更多而仅仅依靠上下文的出现概率（likelihood）进行判断。常见的缺点有：</p>
<ol>
<li>缺少帮助性：无法遵循人类的指引（Instroduction）</li>
<li>捏造性：错误信息</li>
<li>缺少解释性：难以解释如何获得当前结果的</li>
<li>有毒性：有害信息</li>
</ol>
<h2 id="ChatGPT-and-RLHF"><a href="#ChatGPT-and-RLHF" class="headerlink" title="ChatGPT and RLHF"></a>ChatGPT and RLHF</h2><p>为了解决上述的问题，chatGPT基于GPT-3的模型 [3]，加入强化学习方法，首次使用了Reinforcement Learning from Human Feedback [4]。</p>
<h3 id="STEP-1-Supervised-fine-tuning（SFT）"><a href="#STEP-1-Supervised-fine-tuning（SFT）" class="headerlink" title="STEP 1. Supervised fine-tuning（SFT）"></a>STEP 1. Supervised fine-tuning（SFT）</h3><p><img src="https://p.ipic.vip/9k0f24.jpg" alt=""></p>
<p>模型准备阶段。openAI选择了对已有的模型GPT-3.5进行fine-tune的方式而不是重头训练新模型。微调时使用了人工选择及编写的Prompt(指令)和Output(输出)组，对模型进行有监督的训练。</p>
<p>此步骤旨在使用精确而较小的数据集对已有模型针对我们想要执行的任务进行初步的训练，为之后真正的半监督优化做基础。有监督的数据集当然越大越好，但毕竟我们没有那么多时间和精力收集过于庞大的人工数据。</p>
<h3 id="STEP-2-Rewrad-moel（RM）"><a href="#STEP-2-Rewrad-moel（RM）" class="headerlink" title="STEP 2. Rewrad moel（RM）"></a>STEP 2. Rewrad moel（RM）</h3><p><img src="https://p.ipic.vip/t7dxrz.jpg" alt=""></p>
<p>训练奖励模型，我更倾向于理解为评价模型。我们希望能有一个评价方式直接反馈给原模型（策略），而不是需要学习一个值（值函数）。具体方式是让模型对一个prompt输出多个结果，人类通过人工标记的方式对这些结果进行由好到坏的排序。这样，奖励模型习得了基于人类喜好的排序能力。</p>
<p>比起第一步的需要人工从头编写正确答案，此步骤的标记方式显然更轻松和迅速。</p>
<h3 id="STEP-3-Proximal-Policy-Optimization-PPO"><a href="#STEP-3-Proximal-Policy-Optimization-PPO" class="headerlink" title="STEP 3. Proximal Policy Optimization (PPO)"></a>STEP 3. Proximal Policy Optimization (PPO)</h3><p><img src="https://p.ipic.vip/sxgabk.jpg" alt=""></p>
<p>强化学习中常见的PPO（近端策略优化）。前文提到的策略由于粒度过大（优化方向不够明确），因此为保证基于奖励模型的排序结果的优化方向不至于过于偏离现实，要求生成的新策略要与在第一步训练的SFT的输出（旧策略）的差值不得过大（KL散度）。</p>
<p>每一个回合(iteration)一般包含复数个步骤，以保证策略的更新具有一定的远见性，而不仅仅是看眼下的利益。但是对于上一段落的KL散度的惩罚会在每一步中迅速执行，以保证回合内的策略的可信度。</p>
<h2 id="评价方式"><a href="#评价方式" class="headerlink" title="评价方式"></a>评价方式</h2><ul>
<li>有用性</li>
<li>可信度</li>
<li>有毒性</li>
</ul>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>由于多处使用了人工标注，再加上人工调参的过程，几乎每一步都会加入主观的数据偏差。这是该模型的本质局限性。（成也萧何，败也萧何）</p>
<p>其他的问题：</p>
<ol>
<li>缺少控制实验：RLHF在这里面究竟起到了多大作用？</li>
<li>对比数据中缺少真实标注：对比数据即第二步中生成的多个结果。即使里面有的结果非常离谱，人工也只能进行“排序”而无法“告知”，即没有告诉其“应该怎么做”。这导致对比数据的偏差极大。</li>
<li>人类的喜好并不一致。</li>
<li>RM模型对歧义句或同义句的理解程度</li>
<li>富含经验的模型：有时模型会抓到奖励模型的一些“暗门”，据此获得高额奖励。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[3] “Training language models to follow instructions with human feedback”, arXiv:2203.02155 (2022)</p>
<p>[4] 拆解追溯 GPT-3.5 各项能力的起源 : <a href="https://www.notion.so/360081d91ec245f29029d37b54573756">https://www.notion.so/360081d91ec245f29029d37b54573756</a></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>凸优化问题</title>
    <url>/2022/05/06/%E5%87%B8%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<script type="math/tex; mode=display">\text{minimize }f_0(x)</script><script type="math/tex; mode=display">\text{subject to } f_i(x)\le 0, i=1...m</script><script type="math/tex; mode=display">h(x)=0, i=1...p</script><ul>
<li>目标函数(objective f)必须为凸(convex)</li>
<li>不等式(inequality constraint f)约束函数必须为凸</li>
<li>等式约束函数必须为仿射(affine)</li>
<li>定义域是m个凸的下水平集($f_i(x)$)和p个超平面($h(x)$)的交集</li>
<li>我们其实是在一个凸集上极小化一个凸的目标函数</li>
<li>局部最优解自动成为全局最优解</li>
</ul>
<h2 id="最优值与最优解-optimal-value-and-optimal-point"><a href="#最优值与最优解-optimal-value-and-optimal-point" class="headerlink" title="最优值与最优解 optimal value and optimal point"></a>最优值与最优解 optimal value and optimal point</h2><div class="note warning modern"><p>最优值为最优解对应的y值</p>
</div>
<p><strong>最优值</strong>定义为</p>
<script type="math/tex; mode=display">p^*=inf\{f_0(x)|满足约束条件\}</script><ul>
<li>当没有可行点（没有点满足约束条件）时，p为不可行（infeasible）且等于$\infty$</li>
<li>如果$p^*=-\infty$，则称这个问题无下界（unbounded below）</li>
</ul>
<p>当$x^{*}$可行并且$f_0(x^*)=p^{*}$时称之为<strong>最优解</strong></p>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>凸集合与凸函数</title>
    <url>/2022/05/06/%E5%87%B8%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%B8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="1-convex-sets"><a href="#1-convex-sets" class="headerlink" title="1. convex sets"></a>1. convex sets</h2><h3 id="1-1-Line-segmentation-直线分割"><a href="#1-1-Line-segmentation-直线分割" class="headerlink" title="1.1 Line segmentation 直线分割"></a>1.1 Line segmentation 直线分割</h3><script type="math/tex; mode=display">y=\theta x_1+(1-\theta)x_2</script><script type="math/tex; mode=display">y=x_2+\theta(x_1-x_2)</script><blockquote>
<p>$\theta$=1时$y=x_1$,=0时反之，所以称为<strong>直线分割 </strong></p>
<p>根据式2也可以看做是以x_2为基准。向x_1-x_2延伸的一条线<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ykewxdwij208m048q2r.jpg" alt=""></p>
</blockquote>
<h3 id="1-2-affine-sets"><a href="#1-2-affine-sets" class="headerlink" title="1.2 affine sets"></a>1.2 affine sets</h3><p>仿射集C上的任意两点连成的直线属于C<br>即</p>
<script type="math/tex; mode=display">{\theta x_{1}+(1-\theta) x_{2} \in C, \quad \forall x_{1}, x_{2} \in C, \text { and } \theta \in \mathbb{R}}</script><p>扩展到多点上为</p>
<script type="math/tex; mode=display">x_1, x_2 ... x_k \in C</script><script type="math/tex; mode=display">\bf{AND} {\theta}_1+{\theta}_2+...+{\theta}_k=1</script><script type="math/tex; mode=display">\bf{THEN} \theta x_{1}+...+\theta_k x_{k} \in C</script><p>其中，对于属于C的子空间是<br>$V=C-x_0=\{x-x_0|x\in C\}$</p>
<blockquote>
<p>意味着标量乘积之和是闭合的</p>
</blockquote>
<p>子空间维数=仿射集维数</p>
<h3 id="1-3-affine-hull-仿射包"><a href="#1-3-affine-hull-仿射包" class="headerlink" title="1.3 affine hull 仿射包"></a>1.3 affine hull 仿射包</h3><p>aff$C=\{\theta x_{1}+…+\theta_k x_{k}|x_{1}, x_{2}…x_k\in C, \theta_1+\theta_2+…+\theta_k=1\}$</p>
<ol>
<li>C中的所有点的仿射组合组成的集合</li>
<li>仿射集维数=仿射集子空间的维数</li>
<li>是包含C的最小仿射集合</li>
</ol>
<h3 id="1-4-相对内部-relative-interior"><a href="#1-4-相对内部-relative-interior" class="headerlink" title="1.4 相对内部 relative interior"></a>1.4 相对内部 relative interior</h3><p>如果集合C的仿射维数小于n,那么aff$C\ne R ^n$<br>相对内部relint C定义为<br>$\text { relint } C =\{x \in C \mid B(x, r) \cap \operatorname{aff} C \subseteq C \text { for some } r&gt;0\}$<br>其中$B(x,y)=\{y| |y-x|\le r\}$(任意范数均可)</p>
<blockquote>
<p>（呃呃呃开始不说人话了是吧）</p>
</blockquote>
<h3 id="1-5-convex-sets-凸集"><a href="#1-5-convex-sets-凸集" class="headerlink" title="1.5 convex sets 凸集"></a>1.5 convex sets 凸集</h3><p>任意两点的线段都在C中<br>$\theta x_{1}+(1-\theta) x_{2} \in C$<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ym9ddkmrj21610aata5.jpg" alt=""><br>所有点的凸组合为凸包（convex hull）<br>conv$C=\{\theta x_{1}+…+\theta_k x_{k}|x_{1}, x_{2}…x_k\in C, \theta_1+\theta_2+…+\theta_k=1, \theta_i\ge 0\}$<br>凸包是包含C的最小凸集<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ym9epnp9j216e0b3jsg.jpg" alt=""></p>
<h2 id="2-cone-锥"><a href="#2-cone-锥" class="headerlink" title="2. cone 锥"></a>2. cone 锥</h2><p>对与任何x属于C以及$\theta$大于等于0，都有<br>$\theta x\in C$</p>
<h3 id="2-1-凸锥"><a href="#2-1-凸锥" class="headerlink" title="2.1 凸锥"></a>2.1 凸锥</h3><p>锥且凸，即<br>$\theta_1 x_1 + \theta_2 x_2\in C$<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1yme7l34kj21650iddhe.jpg" alt=""></p>
<h3 id="2-2-锥包"><a href="#2-2-锥包" class="headerlink" title="2.2 锥包"></a>2.2 锥包</h3><p>所有锥组合形成的集合</p>
<h2 id="3-重要例子"><a href="#3-重要例子" class="headerlink" title="3. 重要例子"></a>3. 重要例子</h2><h3 id="3-1-一些概念"><a href="#3-1-一些概念" class="headerlink" title="3.1 一些概念"></a>3.1 一些概念</h3><ol>
<li>空集、任意一个点（即单点集）、全空间R”都是Rn的仿射（自然也是凸的)子集。</li>
<li>任意直线是仿射的。如果直线通过零点，则是子空间，因此，也是凸锥。</li>
<li>一条线段是凸的，但不是仿射的（除非退化为一个点）。</li>
<li>一条射线，即具有形式$\{x_0+\theta v|\theta≥0\}$，v≠0的集合，是凸的，但不是仿射的。如果射线的基点$x_0$是0，则它是凸锥。</li>
<li>任意子空间是仿射的、凸锥（自然是凸的）。</li>
</ol>
<h3 id="3-2-超平面"><a href="#3-2-超平面" class="headerlink" title="3.2 超平面"></a>3.2 超平面</h3><p>$\{x|a^Tx=b\}$</p>
<ul>
<li>$a\in R^n且不为0, b\in R$</li>
<li>超平面是关于x的线性方程的解空间（因此是仿射集合）</li>
</ul>
<h3 id="3-3-半空间"><a href="#3-3-半空间" class="headerlink" title="3.3 半空间"></a>3.3 半空间</h3><p>$\{x|a^Tx\le b\}$</p>
<ul>
<li>线性不等式的解空间</li>
<li>凸但不仿射</li>
<li>由超平面切割而成2个半空间</li>
</ul>
<h3 id="3-4-Euclid球"><a href="#3-4-Euclid球" class="headerlink" title="3.4 Euclid球"></a>3.4 Euclid球</h3><p>$\begin{aligned}<br>B\left(x_{c}, r\right) &amp;=\left\{x \mid\left|x-x_{c}\right|_{2} \leq r\right\} \\<br>&amp;=\left\{x \mid\left(x-x_{c}\right)^{\top}\left(x-x_{c}\right) \leq r^{2}\right\}<br>\end{aligned}$</p>
<ul>
<li>$x_c$为球心</li>
<li>r是半径</li>
</ul>
<h3 id="3-5-多面体"><a href="#3-5-多面体" class="headerlink" title="3.5 多面体"></a>3.5 多面体</h3><p>$\begin{array}{r}<br>\mathcal{P}=\left\{x \mid a_{j}^{\top} x-b_{j} \leq 0, j=1, \ldots, m\right. \\<br>\left.c_{j}^{\top} x-d_{j}=0, j=1, \ldots, p\right\}<br>\end{array}$</p>
<ul>
<li>有限个线性等式和不等式的集合（即有限个超平面和半空间的交集）</li>
<li>凸集</li>
</ul>
<h2 id="4-凸集间的保凸运算"><a href="#4-凸集间的保凸运算" class="headerlink" title="4. 凸集间的保凸运算"></a>4. 凸集间的保凸运算</h2><p>凸集之间的运算生成新的凸集</p>
<h3 id="4-1-交集"><a href="#4-1-交集" class="headerlink" title="4.1 交集"></a>4.1 交集</h3><p>$S=S1 \cap S2 $也为凸</p>
<h3 id="4-2-仿射函数"><a href="#4-2-仿射函数" class="headerlink" title="4.2 仿射函数"></a>4.2 仿射函数</h3><p>形同$f(x)=Ax+b$，对于任意点s属于凸集S，$f(s)$为凸<br>同样若有f(s)属于凸集S，则原象$f^{-1}(s)$也为凸</p>
<h3 id="4-3-透视函数"><a href="#4-3-透视函数" class="headerlink" title="4.3 透视函数"></a>4.3 透视函数</h3><p>对于$P(z,t)=z/t$（定义域为dom $P=R^n \times R_{++}$ ）</p>
<blockquote>
<p>$R_{++}为正实数$</p>
</blockquote>
<p>则对任意x属于凸C，P(x)也为凸</p>
<h2 id="5-凸函数"><a href="#5-凸函数" class="headerlink" title="5. 凸函数"></a>5. 凸函数</h2><p>$f:R^n \rightarrow R$, 若dom f为凸集，且x,y属于dom f,且$\theta$在0，1之间，则</p>
<script type="math/tex; mode=display">f(\theta x+(1-\theta) y) \leq \theta f(x)+(1-\theta) f(y)</script><ul>
<li>严格凸函数：无等号</li>
<li>凹函数：当-f是凸</li>
</ul>
<p>最大值函数就是一个凸函数：<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1yqclyw6ij20r207uq3i.jpg" alt=""></p>
<h3 id="5-1-扩展值延伸-Extended-value-extensions"><a href="#5-1-扩展值延伸-Extended-value-extensions" class="headerlink" title="5.1 扩展值延伸 Extended-value extensions"></a>5.1 扩展值延伸 Extended-value extensions</h3><p>定义：当x不在dom f时，我们认为$f(x)=\infty$</p>
<h3 id="5-2-一阶条件"><a href="#5-2-一阶条件" class="headerlink" title="5.2 一阶条件"></a>5.2 一阶条件</h3><ol>
<li>dom f是凸集</li>
<li>$f(y)\ge f(x)+ \bigtriangledown f(x)^T(y-x) $</li>
</ol>
<ul>
<li>右式为f在点x附近的泰勒近似</li>
</ul>
<h3 id="5-3-二阶条件"><a href="#5-3-二阶条件" class="headerlink" title="5.3 二阶条件"></a>5.3 二阶条件</h3><p>$f(x)$的hessian矩阵为半正定，即可认为</p>
<script type="math/tex; mode=display">\bigtriangledown^2f(x) \succeq 0</script><blockquote>
<p>$\succeq$指的是矩阵中的不等式</p>
</blockquote>
<ul>
<li>对于在R上的f，我们简单的认为就是二阶导大于等于0</li>
</ul>
<h3 id="5-4-凸函数间的保凸运算"><a href="#5-4-凸函数间的保凸运算" class="headerlink" title="5.4 凸函数间的保凸运算"></a>5.4 凸函数间的保凸运算</h3><ul>
<li><p>非负加权求和</p>
<script type="math/tex; mode=display">f=w_1f_1+w_2f_2+...+w_kf_k(w非负，f凸函数)</script></li>
<li><p>复合仿射映射</p>
<script type="math/tex; mode=display">g(x)=f(Ax+b)</script><p>f凸时，g凸</p>
</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer-1（队列，栈，链表）</title>
    <url>/2022/10/11/%E5%89%91%E6%8C%87Offer%20-%201/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="栈：先进后出"><a href="#栈：先进后出" class="headerlink" title="栈：先进后出"></a>栈：先进后出</h3><ul>
<li>栈顶，栈底，进栈，出栈</li>
<li>实现方式：顺序栈（数组），链栈（链表）<blockquote>
<p>两种实现方式的区别，仅限于数据元素在实际物理空间上存放的相对位置，顺序栈底层采用的是数组，链栈底层采用的是链表</p>
</blockquote>
</li>
<li>应用：浏览器的回退（<code>page.history</code>），IDE的括号匹配</li>
<li>相关题目：虽然栈的运作机制很简单实现功能也较少，但由于不同于其他结构的先进后出的结构，通过<strong>主栈加辅栈</strong>的组合也能实现不错的功能<ul>
<li>剑指09. 用两个栈实现一个队列</li>
<li>剑指30. 包含min函数的栈</li>
</ul>
</li>
</ul>
<h3 id="队列：先进先出"><a href="#队列：先进先出" class="headerlink" title="队列：先进先出"></a>队列：先进先出</h3><ul>
<li>实现方式： <ol>
<li>列表：<code>list</code>和<code>list.pop(0)</code> </li>
<li>python库：<code>collections.dqueue</code>和<code>dqueue.popleft()</code><blockquote>
<p><strong>时间复杂度</strong>的不同：list 是列表，数组移除头部元素的方式是把后面的元素全部往前移动一位，所以复杂度是 O(N) ； deque 是双端队列，底层是链表，因此头部和尾部是等价的，插入删除都是 O(1)</p>
</blockquote>
</li>
</ol>
</li>
<li>应用：遍历树或图时</li>
<li>相关题目：</li>
</ul>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li>相关题目：<ul>
<li>利用链表有序的特点进行遍历：<ul>
<li>剑指16. 从尾到头打印链表</li>
<li>剑指18. 删除链表的节点</li>
</ul>
</li>
<li>但是也因为有序的特点，如果我们想翻转链表的顺序时就变得麻烦；我们可以使用最常见的遍历改变节点间的指向，也可以使用递归进行反向操作，或者利用特殊的<strong>双指针</strong>模式避免逆序操作。<ul>
<li>剑指24. 翻转链表（中转+递归）</li>
<li>剑指22. 链表中倒数第k个字节（快慢指针）</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="剑指09-用两个栈实现一个队列"><a href="#剑指09-用两个栈实现一个队列" class="headerlink" title="剑指09. 用两个栈实现一个队列"></a>剑指09. 用两个栈实现一个队列</h2><p><strong>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</strong></p>
<p>解题思路：</p>
<p>两个栈，一个主要，一个辅助。添加时可以直接用append实现末尾添加。删除时需要把主栈元素倒回辅助，删掉第一个，再倒回来。</p>
<p>复杂度</p>
<ul>
<li>删除：空间O(n), 时间O(n)</li>
<li>插入：空间O(1), 时间O(1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 注意题目要求：两个栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stack1 = [] <span class="comment">##主队列</span></span><br><span class="line">        self.stack2 = [] <span class="comment">##辅助</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">appendTail</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack1.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteHead</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.stack1:</span><br><span class="line">            <span class="comment">## 取出</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.stack1)-<span class="number">1</span>):</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">            deleted = self.stack1.pop()</span><br><span class="line"></span><br><span class="line">            <span class="comment">## 放回stack1</span></span><br><span class="line">            <span class="keyword">while</span> self.stack2 :</span><br><span class="line">                self.stack1.append(self.stack2.pop())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CQueue()</span></span><br><span class="line"><span class="comment"># obj.appendTail(value)</span></span><br><span class="line"><span class="comment"># param_2 = obj.deleteHead()</span></span><br></pre></td></tr></table></figure>
<h2 id="剑指30-包含min函数的栈"><a href="#剑指30-包含min函数的栈" class="headerlink" title="剑指30. 包含min函数的栈"></a>剑指30. 包含min函数的栈</h2><p><strong>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)</strong></p>
<p>解题思路：</p>
<ul>
<li>栈的特性：top没有出来之前，下面的是一定存在的。换言之，当top在的时候，对应的当前栈的最小值是不会变的。</li>
<li>创建动态储存最小值的辅助栈。push的时候对比上一个最小值和当前input，将小的push进辅助栈。pop的时候一并pop辅助</li>
<li>为避免第一个push时out of index，初始化辅助栈时先加入一个无穷大(<code>math.inf</code>)</li>
</ul>
<p>Tip</p>
<ol>
<li>python数组索引可以通过负值来倒着取出</li>
<li>栈顶是指最后一个进来的</li>
<li><code>list.pop()</code>默认pop最后一位</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.min_stack = [math.inf]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> x &lt; self.min_stack[-<span class="number">1</span>]:</span><br><span class="line">            self.min_stack.append(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.min_stack.append(self.min_stack[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line">        self.min_stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        result = self.stack[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">min</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.min_stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.min()</span></span><br></pre></td></tr></table></figure>
<h2 id="剑指16-从尾到头打印链表"><a href="#剑指16-从尾到头打印链表" class="headerlink" title="剑指16. 从尾到头打印链表"></a>剑指16. 从尾到头打印链表</h2><p><strong>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</strong></p>
<p>解题思路：</p>
<p>用list顺序存储单向链表，使用切片直接倒序输出。</p>
<p>Tip：</p>
<ul>
<li>列表切片规则<code>List[start:stop:step]</code>，不加则是默认全部区间</li>
<li><code>List[::-1]</code>则代表倒置列表</li>
</ul>
<p>复杂度</p>
<ul>
<li>时间O(n)， 空间O(n)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePrint</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            result.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="剑指24-翻转链表（中转-递归）"><a href="#剑指24-翻转链表（中转-递归）" class="headerlink" title="剑指24. 翻转链表（中转+递归）"></a>剑指24. 翻转链表（中转+递归）</h2><p><strong>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</strong></p>
<p>解题思路：<br>需要解决的问题其实有两个：1. 如何改变node之间的指向 2. 如何保存头部节点</p>
<ol>
<li>使用<strong>中转点</strong>对上一个node保存，遍历链表同时改变指向，最后一个到达的就是新链表的头部节点</li>
<li>递归。只有到达最后一个节点后才开始进行翻转。这里通过返回值不停传递末节点，即新链表的头结点。<ul>
<li>传递参数：当前节点和下一节点</li>
<li>停止条件：当前节点为空</li>
<li>返回值：上一节点</li>
<li>执行动作：将下一节点指向当前节点</li>
</ul>
</li>
</ol>
<p>复杂度</p>
<ul>
<li>时间：O(n)，空间：O(2)</li>
</ul>
<h3 id="中转站法"><a href="#中转站法" class="headerlink" title="中转站法"></a>中转站法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        prevNode = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            head.<span class="built_in">next</span> = prevNode</span><br><span class="line">            prevNode = head</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prevNode</span><br></pre></td></tr></table></figure>
<ul>
<li>时间：O(n)，</li>
<li>空间：O(n):递归深度达到n，需要n的空间</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recur</span>(<span class="params">cur: ListNode, prev: ListNode</span>) -&gt; ListNode:</span><br><span class="line"></span><br><span class="line">            <span class="comment">## 迭代中止：到达最后一个Node的时候next会变成None，这时返回最后一个Node</span></span><br><span class="line">            <span class="comment">## 最后一个Node会变成新链表的head，使用变量进行保存</span></span><br><span class="line">            <span class="keyword">if</span> cur:</span><br><span class="line">                head = recur(cur.<span class="built_in">next</span>, cur)</span><br><span class="line">                cur.<span class="built_in">next</span> = prev</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> prev</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> recur(head, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<h2 id="剑指18-删除链表的节点"><a href="#剑指18-删除链表的节点" class="headerlink" title="剑指18. 删除链表的节点"></a>剑指18. 删除链表的节点</h2><p><strong>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</strong></p>
<p><strong>返回删除后的链表的头节点。</strong></p>
<p>时间O(n)， 空间O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, head: ListNode, val: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head : <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> head.val == val : <span class="keyword">return</span> head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        result = head </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span> :</span><br><span class="line">            <span class="keyword">if</span> head.<span class="built_in">next</span>.val == val :</span><br><span class="line">                head.<span class="built_in">next</span> = head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h2 id="剑指22-链表中倒数第k个字节（快慢指针）"><a href="#剑指22-链表中倒数第k个字节（快慢指针）" class="headerlink" title="剑指22. 链表中倒数第k个字节（快慢指针）"></a>剑指22. 链表中倒数第k个字节（快慢指针）</h2><p><strong>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</strong></p>
<p><strong>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</strong></p>
<blockquote>
<p>遍历法很容易想到就不在这里赘述了</p>
</blockquote>
<ul>
<li>时间O(n) 空间O(1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKthFromEnd</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        slow, fast = head, head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>) :</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> fast.<span class="built_in">next</span> :</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<h2 id="剑指25-合并两个排序的链表"><a href="#剑指25-合并两个排序的链表" class="headerlink" title="剑指25. 合并两个排序的链表"></a>剑指25. 合并两个排序的链表</h2><p><strong>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</strong></p>
<ul>
<li>善用伪头结点可以减少很多步骤，如判断哪个才是头结点造成的代码行数增加</li>
<li>因为是链表结构而非数组，因此不用考虑最后剩下的需要用while再一个个塞进去</li>
<li>时间O(n)， 空间O(1)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:  </span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        cur = head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2 :</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val :</span><br><span class="line">                cur.<span class="built_in">next</span>, l1 = l1, l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                cur.<span class="built_in">next</span>, l2 = l2, l2.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> l1 :</span><br><span class="line">            cur.<span class="built_in">next</span> = l1</span><br><span class="line">        <span class="keyword">if</span> l2 :</span><br><span class="line">            cur.<span class="built_in">next</span> = l2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>无约束最优化</title>
    <url>/2022/05/04/%E6%97%A0%E7%BA%A6%E6%9D%9F%E6%9C%80%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="1-Minizer"><a href="#1-Minizer" class="headerlink" title="1. Minizer"></a>1. Minizer</h2><ol>
<li>全局最小值 Global Minizer</li>
<li>局部最小值 Local Minizer<ul>
<li>weak </li>
<li>strict</li>
<li>孤立的局部最小值isolated local minimizer <div class="note success modern"><p>对于凸函数，局部最小值立即成为全局最小值</p>
</div>
</li>
</ul>
</li>
</ol>
<h2 id="2-局部最小值条件"><a href="#2-局部最小值条件" class="headerlink" title="2. 局部最小值条件"></a>2. 局部最小值条件</h2><ol>
<li>一阶必要条件（FIRST-ORDER NECESSARY CONDITIONS）<ol>
<li>函数$f(x)$在点$x^*$可微</li>
<li>梯度${\nabla f(x^*)=0}$</li>
</ol>
</li>
<li>二阶必要条件<ol>
<li>满足一阶</li>
<li>hesse矩阵${\nabla^2 f(x^*)}$半正定   </li>
</ol>
</li>
</ol>
<div class="tabs" id="1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#1-1">海塞矩阵</button></li><li class="tab"><button type="button" data-href="#1-2">半正定值</button></li><li class="tab"><button type="button" data-href="#1-3">海塞矩阵的半正定值</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="1-1"><p><img src="https://ds055uzetaobb.cloudfront.net/brioche/uploads/gVN1lN1A28-hessian.png?width=1200" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><p>半正定值：</p>
<ol>
<li>对于所有x不等于0，都有 ${x^TAx≥0}$</li>
<li>且对某个x不等于0,有 ${x^TAx&gt;0}$</li>
</ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><p>因为hesse矩阵是对称矩阵所以有以下性质：（仅限于对称矩阵！！）<br>半正定：所有特征值都大于等于0<br>正定：所有特征值都大于0<br>负定：所有特征值都小于0</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<mark class="hl-label red">现在虽然知道了确认某点是否为最小值的算法，但是对于如何找到这个点我们还无从得知（总不能把所有点都算一遍吧）</mark> 
<h2 id="3-直线探索策略-line-search-strategy"><a href="#3-直线探索策略-line-search-strategy" class="headerlink" title="3. 直线探索策略 line search strategy"></a>3. 直线探索策略 line search strategy</h2><ol>
<li>Line Serch<br> 设在某点$x_k$，寻找方向$p_k$和步长$\alpha$使得min$f(x_k+\alpha p_k)$<br> <strong>需求值：方向和步长</strong></li>
<li>Trust Region<br> 对于点x_k上的近似函数求最小值：min$m_k(x_k+p_k)$。同时，近似函数是有限的，所以可信赖区间需要被确定。<br> <strong>需求值：近似函数和可信赖区间p</strong></li>
</ol>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>最小二乘问题</title>
    <url>/2022/05/05/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="最小二乘（LEAST-SQUARES）问题定义"><a href="#最小二乘（LEAST-SQUARES）问题定义" class="headerlink" title="最小二乘（LEAST-SQUARES）问题定义"></a>最小二乘（LEAST-SQUARES）问题定义</h2><p>${f_0(x)=||Ax-b||^2_2<br>        =\sum_{i=1}^k({a_i}^Tx-b_i)^2}$</p>
<blockquote>
<p>2-范数<br>${||x||_2=(x,x)^{1/2}=\sqrt{\sum_{i=1}^n x_i^2}}$</p>
</blockquote>
<h2 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h2><p>上面的式子可被简化为：<br>${(A^TA)x = A^Tb}$<br>${x = (A^TA)^{-1}A^Tb}$<br>代入原式并求hesse矩阵的话<br>${\nabla^2 ||Ax-b||^2_2=2A^TA}$<br>→ 变成了确认 ${2A^TA}$的正定值与否的问题</p>
<h2 id="补充：最小二乘"><a href="#补充：最小二乘" class="headerlink" title="补充：最小二乘"></a>补充：最小二乘</h2><ul>
<li>如下二维平面图中有很多个点，假设我们想用一条直线来拟合数据，即期望能找到一条直线能最好地穿过这些数据点。</li>
<li>一个点就可以构造一个方程，而未知数显然只有两个（直线的斜率和截距），因此这就是一个超定系统，我们是没有办法找到一条完美的直线，使得上述的点都在直线上。因此，我们只能期望找到一条最好的“适配（best fitting line）”直线来拟合这些数据</li>
<li>有x作为自变量，y表示x对应的真实值，$y^hat$表示由拟合直线对应的预测值</li>
<li>找一条直线能使得所有点离这个直线的距离平均值最小的这种近似的结果就是回归分析的目标。</li>
<li>最小二乘法主要包含了两大类方法，一种是线性最小二乘法（Linear Least Squares），一种是非线性最小二乘法（Nonlinear Least Squares）。</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
      </categories>
      <tags>
        <tag>optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>闲谈-关于美术馆拍摄的变形问题</title>
    <url>/2022/05/05/%E9%97%B2%E8%B0%88-%E5%85%B3%E4%BA%8E%E7%BE%8E%E6%9C%AF%E9%A6%86%E6%8B%8D%E6%91%84%E7%9A%84%E5%8F%98%E5%BD%A2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>前几天去艺术馆拍了不少喜欢的画作，本想回来美美做墙纸之类的，结果….<br><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1xc5rlm0hj213y0u0afo.jpg" alt="除去我摄影水平不够导致的没有完美对齐的问题，和红框相比能明显看出来似乎加了鱼眼效果般突出来了点"></p>
<p><em>除去我摄影水平不够导致的没有完美对齐的问题，和红框相比能明显看出来似乎加了鱼眼效果般突出来了点</em></p>
<h2 id="镜头变形"><a href="#镜头变形" class="headerlink" title="镜头变形"></a>镜头变形</h2><p><img src="https://i.guancha.cn/bbs/2020/06/21/20200621224008407.png?imageView2/2/w/500/format/png" alt="枕形变形与鼓形变形"></p>
<blockquote>
<p>“<em>对于一般的风景画，没有多少直线，对枕形变形不太敏感；但要是以建筑为主体，或者是有较多靠近画框边缘的直线的抽象画，枕形变形就会比较扎眼。如果要把画框拍出来，平直线条紧贴着画面边缘，枕形变形特别容易显出来，佳能红圈20-70/2.8都压不住，慢说任何小数码相机了。这是拍摄绘画的“不利条件”。</em>“</p>
</blockquote>
<h2 id="球差（球面収差）"><a href="#球差（球面収差）" class="headerlink" title="球差（球面収差）"></a>球差（球面収差）</h2><p><img src="http://www.kansmemo.com/archives/001/201009/4c99aa26d1e4d.png" alt=""><br>透过镜头外侧的光和透镜片中心(近轴)附近的光,因为焦点位置不同而产生变形。原理上来说，只要镜头为球面镜头这一现象就不可避免。<br>相反,球面收差可以通过使用适当设计——非球面镜头来消除。所以,最近的镜头中非球面镜头开始被普遍使用。<br><img src="http://www.kansmemo.com/archives/001/201009/4c99aa29663c5.png" alt=""></p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>物理学的稀巴烂所以基本还停留在初中学的“凸透镜光线汇聚成一点”，所以其实理解这个费了好大的功夫。一些关于<strong>为什么与教科书不同，凸透镜的焦点并不能完美汇聚于一点</strong>的补充如下：</p>
<blockquote>
<p>聚集到一点，需要几个因素<br>1、理想平行光<br>2、理想凸透镜<br>3、理想单一频率<br>4、理想粒子特性(实际上光具有波粒两相性)</p>
</blockquote>
<p>[1]<a href="https://www.zhihu.com/question/272102579/answer/1297496356">https://www.zhihu.com/question/272102579/answer/1297496356</a><br>[2]<a href="http://www.kansmemo.com/photo/camera/principles/entry-191.html">http://www.kansmemo.com/photo/camera/principles/entry-191.html</a></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
</search>
